{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/light/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/light/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/light/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/light/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/light/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/light/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/light/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/light/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/light/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/light/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/light/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"themes/light/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/light/source/css/font/fontawesome-webfont.eot","path":"css/font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/light/source/css/font/fontawesome-webfont.svg","path":"css/font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/light/source/css/font/fontawesome-webfont.ttf","path":"css/font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/light/source/css/font/fontawesome-webfont.woff","path":"css/font/fontawesome-webfont.woff","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Cmake.md","hash":"6817a27d3dc5a71f06487f5e4d57b9ba4545c2ca","modified":1635839805908},{"_id":"source/_posts/Docker基本概念.md","hash":"3518c689f83baf463c1f1c088cd90e0f3c7dec3d","modified":1635839805908},{"_id":"source/_posts/Hystrix-服务容错保护.md","hash":"3b24ed76f25364ed2a6fc7cdd9f65f8166076d0d","modified":1635839805912},{"_id":"source/_posts/Kotlin.md","hash":"6b9f6cdf049d7a123cfbc5e0bda099340a95c2e7","modified":1635839805912},{"_id":"source/_posts/Linux c 连接mysql.md","hash":"c0604a209defada30d0d693958a67be7224c3300","modified":1635839805912},{"_id":"source/_posts/Linux权限.md","hash":"ce6113c57f6aaa4458240bb4161662e957a06379","modified":1635910108091},{"_id":"source/_posts/mongo.md","hash":"bb6e88c7eff717de46810da785fecf5b651272cc","modified":1635839805913},{"_id":"source/_posts/位运算.md","hash":"df2b40449043f7a52207006b1e7df552572dfb27","modified":1635906252401},{"_id":"source/_posts/安卓基础知识.md","hash":"b9a4e7947033d7743911d57a359075fdea85d1a9","modified":1635839805914},{"_id":"source/_posts/操作系统中-heap-和-stack-的区别.md","hash":"366df43a114cd4c1377ddeaa31ca1061da639a2f","modified":1635839805914},{"_id":"source/_posts/数据在内存中的存储.md","hash":"b07766bccc844e23e340f4f844a268e7196baf53","modified":1635839805914},{"_id":"source/_posts/正则表达式.md","hash":"88430eb170a0915ccbcf6d40ed1364e657c76723","modified":1635839805915},{"_id":"source/_posts/毛选.md","hash":"43005752e98669ca02cd8a768b6ecf1a8eb9a49a","modified":1635902497544},{"_id":"themes/light/source/css/_base/utils.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1635928056624},{"_id":"themes/light/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1635928056604},{"_id":"themes/light/LICENSE","hash":"17d3ed51d6d6962155f7dacd4f101f4969ad0bbe","modified":1635928056604},{"_id":"themes/light/README.md","hash":"a4f127a5d8c58b88b13c7bbe5e54a926bd3861d5","modified":1635928056604},{"_id":"themes/light/_config.yml","hash":"ae923b811f913970fc04248c31e4cdfe4fceb4e1","modified":1635928056605},{"_id":"themes/light/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1635928056606},{"_id":"themes/light/languages/de.yml","hash":"1ebe2d4f1b48c84e004c933bec65731fb54c9998","modified":1635928056606},{"_id":"themes/light/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1635928056606},{"_id":"themes/light/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1635928056607},{"_id":"themes/light/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1635928056607},{"_id":"themes/light/languages/en.yml","hash":"feb1dd022dc8897d65baa5b927de2a3d4178d798","modified":1635928056608},{"_id":"themes/light/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1635928056608},{"_id":"themes/light/languages/es.yml","hash":"727707b95580bbe9773edef4c84a9735fd537742","modified":1635928056608},{"_id":"themes/light/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1635928056609},{"_id":"themes/light/languages/ja.yml","hash":"3b43fc314265c1260a41d1600598cd2f0ab9d087","modified":1635928056609},{"_id":"themes/light/languages/lt-LT.yml","hash":"0b51f65a5e5059eee74c219f3dd8ec501a28c891","modified":1635928056609},{"_id":"themes/light/languages/lt.yml","hash":"f84b72c94b2b6beb84df9e36e88037e74d3e3c7b","modified":1635928056610},{"_id":"themes/light/languages/no.yml","hash":"d9a1b34d590f94ab5c03809754e62bc4cf0e8d0f","modified":1635928056610},{"_id":"themes/light/languages/pl-PL.yml","hash":"8a7089a3e060b5d159de3ca519f190231c6ccf53","modified":1635928056610},{"_id":"themes/light/languages/pl.yml","hash":"19313b4c80c50196c364afe932dad3a975782817","modified":1635928056610},{"_id":"themes/light/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1635928056611},{"_id":"themes/light/languages/ru.yml","hash":"37161bb9b6cc2dae1f53837185be32e7a0b8abfa","modified":1635928056611},{"_id":"themes/light/languages/zh-CN.yml","hash":"751f1a2bbfb6736c71e846493ae0fb7ef7dc778d","modified":1635928056611},{"_id":"themes/light/languages/zh-TW.yml","hash":"b2474b775a8fa0fa3e9e3c58ddb11b20cf65dbc5","modified":1635928056612},{"_id":"themes/light/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1635928056621},{"_id":"themes/light/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1635928056621},{"_id":"themes/light/layout/index.ejs","hash":"c7cf84c84c26f1adfc249bc9a7605206fa245f73","modified":1635928056622},{"_id":"themes/light/layout/layout.ejs","hash":"dd4b0fce0c49cd6282527b89583ecceaf3ce6ab3","modified":1635928056622},{"_id":"themes/light/layout/page.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1635928056622},{"_id":"themes/light/layout/post.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1635928056623},{"_id":"themes/light/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1635928056623},{"_id":"themes/light/layout/_partial/after_footer.ejs","hash":"edee9e48ffb4934ddd21ad5520ad30b641b8e765","modified":1635928056612},{"_id":"themes/light/layout/_partial/archive.ejs","hash":"f42fc09052f70e21b1103faf681733694d923419","modified":1635928056613},{"_id":"themes/light/layout/_partial/article.ejs","hash":"0dc313bca098737a14e73171ef8dda4cc02a663a","modified":1635928056613},{"_id":"themes/light/layout/_partial/comment.ejs","hash":"56786339f66a1fb56d29070633b27bd34ae3f9c3","modified":1635928056614},{"_id":"themes/light/layout/_partial/facebook_comment.ejs","hash":"49ee54e84fe2b70bd9540e2eeba5a85f744941b0","modified":1635928056614},{"_id":"themes/light/layout/_partial/footer.ejs","hash":"092bea0a0cdb4ab976723bbce3771bc35a96fdc6","modified":1635928056615},{"_id":"themes/light/layout/_partial/head.ejs","hash":"8c958d432491724acc4c99609f1ba93f788c01be","modified":1635928056615},{"_id":"themes/light/layout/_partial/google_analytics.ejs","hash":"f73d8de209cb3fddc3aa33d6a4ac56caa18a79af","modified":1635928056615},{"_id":"themes/light/layout/_partial/header.ejs","hash":"e1cc303f4e942e4b263fe6b103eaa4c1a473f5d2","modified":1635928056616},{"_id":"themes/light/layout/_partial/pagination.ejs","hash":"2dd06ecc75f5ac4d7cfd427ec0262899977e4865","modified":1635928056616},{"_id":"themes/light/layout/_partial/sidebar.ejs","hash":"016441ca9534769d8e151cffe4027686e9c86f18","modified":1635928056618},{"_id":"themes/light/layout/_widget/category.ejs","hash":"a5a21f584477103fc872a3e6ab8aaea1406b7d3b","modified":1635928056619},{"_id":"themes/light/layout/_widget/recent_posts.ejs","hash":"ae6056d6e9423cd8ebd7c4ae5aafd576638e4992","modified":1635928056619},{"_id":"themes/light/layout/_widget/search.ejs","hash":"7d102ee25a9bf0e9c7a621c5cdb4ceedaddad177","modified":1635928056620},{"_id":"themes/light/layout/_widget/tag.ejs","hash":"9f212961ebe21c442d47dbe5bbaa7a60d26195c6","modified":1635928056620},{"_id":"themes/light/layout/_widget/tagcloud.ejs","hash":"139e91b1e6abcc1e3883bcc03a9a1a7f1d891d7a","modified":1635928056620},{"_id":"themes/light/source/css/style.styl","hash":"8e8458e78717c49c4ff278b741258d77301f6be4","modified":1635928056636},{"_id":"themes/light/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1635928056637},{"_id":"themes/light/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1635928056638},{"_id":"themes/light/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1635928056638},{"_id":"themes/light/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1635928056639},{"_id":"themes/light/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1635928056639},{"_id":"themes/light/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1635928056640},{"_id":"themes/light/source/fancybox/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1635928056640},{"_id":"themes/light/source/fancybox/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1635928056641},{"_id":"themes/light/source/js/gallery.js","hash":"735a714e54f0ac229f292a90df3a1f882904f6c7","modified":1635928056642},{"_id":"themes/light/source/js/jquery.imagesloaded.min.js","hash":"28ef4346743a60c896a9ae492a544c0854904350","modified":1635928056643},{"_id":"themes/light/layout/_partial/post/category.ejs","hash":"3f5e13bf0f7161feb8cc1a5ca12e4df20594d1aa","modified":1635928056617},{"_id":"themes/light/layout/_partial/post/gallery.ejs","hash":"fc23ef9b5a412e05436f68ff47146b860d2d4225","modified":1635928056617},{"_id":"themes/light/layout/_partial/post/share.ejs","hash":"b4d48ed6a28ed90182704beb3041e8c6b36a04ac","modified":1635928056617},{"_id":"themes/light/layout/_partial/post/tag.ejs","hash":"5f55c1a802f65357d3398f64a07917beb2454498","modified":1635928056618},{"_id":"themes/light/layout/_partial/post/title.ejs","hash":"a95cb0f6190b503b28ca69e8a2d4ea52f6ef6ffe","modified":1635928056618},{"_id":"themes/light/source/css/_base/layout.styl","hash":"b26cd4768466f637b620029b314dd50a06c98b8c","modified":1635928056624},{"_id":"themes/light/source/css/_base/variable.styl","hash":"832fecbb623c8fba9419d6a93586126d44b43cc6","modified":1635928056625},{"_id":"themes/light/source/css/_partial/archive.styl","hash":"b6fa84ea80bfbdb3a93f64c06a8c652e4242128e","modified":1635928056625},{"_id":"themes/light/source/css/_partial/article.styl","hash":"0598a40f8693bdb03c739669cfc6b72fe20c628a","modified":1635928056625},{"_id":"themes/light/source/css/_partial/comment.styl","hash":"6fa67d96903ac3b1674e6c8d4c801e16115808e0","modified":1635928056626},{"_id":"themes/light/source/css/_partial/footer.styl","hash":"821d50a9d45afec0274e1e64c2b37a71f3611c01","modified":1635928056626},{"_id":"themes/light/source/css/_partial/header.styl","hash":"ad67bf40a0cafb1e5514b058c853c517e602fe44","modified":1635928056627},{"_id":"themes/light/source/css/_partial/index.styl","hash":"eb0f1536a57cca57d9a280191fbb63185c266ee8","modified":1635928056627},{"_id":"themes/light/source/css/_partial/sidebar.styl","hash":"213a16c3206d045ca01b0abf8891e96421d61fb9","modified":1635928056627},{"_id":"themes/light/source/css/_partial/syntax.styl","hash":"d4fd5c33c9ea9d657641e8252a00e7d0b1db6120","modified":1635928056628},{"_id":"themes/light/source/css/font/fontawesome-webfont.eot","hash":"d775f599ff3f23be082e6a9604b4898718923a37","modified":1635928056629},{"_id":"themes/light/source/css/font/fontawesome-webfont.woff","hash":"0612cddf2f835cceffccc88fd194f97367d0b024","modified":1635928056636},{"_id":"themes/light/source/js/jquery-3.4.1.min.js","hash":"b15f7cfa79519756dff1ad22553fd0ed09024343","modified":1635928056643},{"_id":"themes/light/source/css/font/fontawesome-webfont.svg","hash":"ff51bbb11dfe58345f41cead2c425d6e8be28176","modified":1635928056631},{"_id":"themes/light/source/css/font/fontawesome-webfont.ttf","hash":"a9468f6a1fe965fbcaf5a1bd6c11705e2fc5f84c","modified":1635928056635}],"Category":[{"name":"c/c++","_id":"ckvj9gble0002zsw73t6pczd3"},{"name":"常用工具","_id":"ckvj9gblj0007zsw7hidu4zrb"},{"name":"java","_id":"ckvj9gbln000czsw7fva99ays"},{"name":"android","_id":"ckvj9gblr000kzsw7hrrxet9d"},{"name":"操作系统","_id":"ckvj9gblv000rzsw79x5u7kve"},{"name":"数据库","_id":"ckvj9gbly000xzsw7a5qtdljx"},{"name":"算法","_id":"ckvj9gbm00012zsw72piuexdk"},{"name":"计算机基础","_id":"ckvj9gbm40018zsw7bwwb4r5o"},{"name":"哲学","_id":"ckvj9gbma001lzsw7arp4bp9p"}],"Data":[],"Page":[],"Post":[{"title":"Cmake 指令","date":"2021-11-02T07:56:45.908Z","_content":"\n## 二进制，是计算机处理数据的基础\n\n内存条是一个非常精密的部件，包含了上一个电子元器件，它们很小，达到了纳米级别。这些元器件实际上就是电路。电路的电压会变化，要么0V，要么5V。只有这\n两种电压。5V是通电，用1来表示，0V是断电，用0来表示。所以，一个元器件有两种状态，0和1.\n我们通过电路来控制这些元器件的通断电，会得到很多0,1的组合。例如8个元器件，有2^8=256种不同组合。给组合赋予定义，则构成了值。\n\n一般情况下我们不一个一个使用元器件，而是将8个元器件看做一个单位。1表示为0000001；\n\n一个元器件称为1个比特（bit）,8个元器件称为一字节（byte），以此类推。1024个字节为1kb；。。。\n\n## 指令\n\n### PROJECT\n\nPROJECT(projectname [CXX][C][JAVA])\n用于定义工程名称，并可以指定工程支持的语言。支持的语言列表是可以忽略的，默认情况表示支持所有语言。\n这个指令隐式的定义了两个cmake 变量：<projectname>_SOURCE_DIR 、<projectname>_BINARY_DIR.\n同时cmake系统也帮我们预定义了PROJECT_SOURCE_DIR 以及 PROJECT_BINARY_DIR\n\n### SET\n\nSET(VAR[VALUE][CACHE TYPE DOCSTRING[FORCE]])\n显式的定义变量\n\n### MESSAGE\n\nMESSAGE([SEND_ERROR|STATUS|FATAL_ERROR]\"message to display\")\n\n输出信息\n- SEND_ERROR ,产生错误，生成过程被跳过。\n- STATUS ,输出前缀为1的信息。\n- FATAL_ERROR,立即终止所有的cmake过程。\n\n### ADD_EXECUTABLE\n\nADD_EXECUTABLE(hello,)","source":"_posts/Cmake.md","raw":"---\ntitle: Cmake 指令\ndate: 2020-01-304 15:58:02\ncategories: c/c++\ntags: \n- c/c++\n- linux\n---\n\n## 二进制，是计算机处理数据的基础\n\n内存条是一个非常精密的部件，包含了上一个电子元器件，它们很小，达到了纳米级别。这些元器件实际上就是电路。电路的电压会变化，要么0V，要么5V。只有这\n两种电压。5V是通电，用1来表示，0V是断电，用0来表示。所以，一个元器件有两种状态，0和1.\n我们通过电路来控制这些元器件的通断电，会得到很多0,1的组合。例如8个元器件，有2^8=256种不同组合。给组合赋予定义，则构成了值。\n\n一般情况下我们不一个一个使用元器件，而是将8个元器件看做一个单位。1表示为0000001；\n\n一个元器件称为1个比特（bit）,8个元器件称为一字节（byte），以此类推。1024个字节为1kb；。。。\n\n## 指令\n\n### PROJECT\n\nPROJECT(projectname [CXX][C][JAVA])\n用于定义工程名称，并可以指定工程支持的语言。支持的语言列表是可以忽略的，默认情况表示支持所有语言。\n这个指令隐式的定义了两个cmake 变量：<projectname>_SOURCE_DIR 、<projectname>_BINARY_DIR.\n同时cmake系统也帮我们预定义了PROJECT_SOURCE_DIR 以及 PROJECT_BINARY_DIR\n\n### SET\n\nSET(VAR[VALUE][CACHE TYPE DOCSTRING[FORCE]])\n显式的定义变量\n\n### MESSAGE\n\nMESSAGE([SEND_ERROR|STATUS|FATAL_ERROR]\"message to display\")\n\n输出信息\n- SEND_ERROR ,产生错误，生成过程被跳过。\n- STATUS ,输出前缀为1的信息。\n- FATAL_ERROR,立即终止所有的cmake过程。\n\n### ADD_EXECUTABLE\n\nADD_EXECUTABLE(hello,)","slug":"Cmake","published":1,"updated":"2021-11-02T07:56:45.908Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gbl40000zsw7gw1a4ruv","content":"<h2 id=\"二进制，是计算机处理数据的基础\"><a href=\"#二进制，是计算机处理数据的基础\" class=\"headerlink\" title=\"二进制，是计算机处理数据的基础\"></a>二进制，是计算机处理数据的基础</h2><p>内存条是一个非常精密的部件，包含了上一个电子元器件，它们很小，达到了纳米级别。这些元器件实际上就是电路。电路的电压会变化，要么0V，要么5V。只有这<br>两种电压。5V是通电，用1来表示，0V是断电，用0来表示。所以，一个元器件有两种状态，0和1.<br>我们通过电路来控制这些元器件的通断电，会得到很多0,1的组合。例如8个元器件，有2^8=256种不同组合。给组合赋予定义，则构成了值。</p>\n<p>一般情况下我们不一个一个使用元器件，而是将8个元器件看做一个单位。1表示为0000001；</p>\n<p>一个元器件称为1个比特（bit）,8个元器件称为一字节（byte），以此类推。1024个字节为1kb；。。。</p>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h3 id=\"PROJECT\"><a href=\"#PROJECT\" class=\"headerlink\" title=\"PROJECT\"></a>PROJECT</h3><p>PROJECT(projectname [CXX][C][JAVA])<br>用于定义工程名称，并可以指定工程支持的语言。支持的语言列表是可以忽略的，默认情况表示支持所有语言。<br>这个指令隐式的定义了两个cmake 变量：<projectname>_SOURCE_DIR 、<projectname>_BINARY_DIR.<br>同时cmake系统也帮我们预定义了PROJECT_SOURCE_DIR 以及 PROJECT_BINARY_DIR</p>\n<h3 id=\"SET\"><a href=\"#SET\" class=\"headerlink\" title=\"SET\"></a>SET</h3><p>SET(VAR[VALUE][CACHE TYPE DOCSTRING[FORCE]])<br>显式的定义变量</p>\n<h3 id=\"MESSAGE\"><a href=\"#MESSAGE\" class=\"headerlink\" title=\"MESSAGE\"></a>MESSAGE</h3><p>MESSAGE([SEND_ERROR|STATUS|FATAL_ERROR]”message to display”)</p>\n<p>输出信息</p>\n<ul>\n<li>SEND_ERROR ,产生错误，生成过程被跳过。</li>\n<li>STATUS ,输出前缀为1的信息。</li>\n<li>FATAL_ERROR,立即终止所有的cmake过程。</li>\n</ul>\n<h3 id=\"ADD-EXECUTABLE\"><a href=\"#ADD-EXECUTABLE\" class=\"headerlink\" title=\"ADD_EXECUTABLE\"></a>ADD_EXECUTABLE</h3><p>ADD_EXECUTABLE(hello,)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"二进制，是计算机处理数据的基础\"><a href=\"#二进制，是计算机处理数据的基础\" class=\"headerlink\" title=\"二进制，是计算机处理数据的基础\"></a>二进制，是计算机处理数据的基础</h2><p>内存条是一个非常精密的部件，包含了上一个电子元器件，它们很小，达到了纳米级别。这些元器件实际上就是电路。电路的电压会变化，要么0V，要么5V。只有这<br>两种电压。5V是通电，用1来表示，0V是断电，用0来表示。所以，一个元器件有两种状态，0和1.<br>我们通过电路来控制这些元器件的通断电，会得到很多0,1的组合。例如8个元器件，有2^8=256种不同组合。给组合赋予定义，则构成了值。</p>\n<p>一般情况下我们不一个一个使用元器件，而是将8个元器件看做一个单位。1表示为0000001；</p>\n<p>一个元器件称为1个比特（bit）,8个元器件称为一字节（byte），以此类推。1024个字节为1kb；。。。</p>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h3 id=\"PROJECT\"><a href=\"#PROJECT\" class=\"headerlink\" title=\"PROJECT\"></a>PROJECT</h3><p>PROJECT(projectname [CXX][C][JAVA])<br>用于定义工程名称，并可以指定工程支持的语言。支持的语言列表是可以忽略的，默认情况表示支持所有语言。<br>这个指令隐式的定义了两个cmake 变量：<projectname>_SOURCE_DIR 、<projectname>_BINARY_DIR.<br>同时cmake系统也帮我们预定义了PROJECT_SOURCE_DIR 以及 PROJECT_BINARY_DIR</p>\n<h3 id=\"SET\"><a href=\"#SET\" class=\"headerlink\" title=\"SET\"></a>SET</h3><p>SET(VAR[VALUE][CACHE TYPE DOCSTRING[FORCE]])<br>显式的定义变量</p>\n<h3 id=\"MESSAGE\"><a href=\"#MESSAGE\" class=\"headerlink\" title=\"MESSAGE\"></a>MESSAGE</h3><p>MESSAGE([SEND_ERROR|STATUS|FATAL_ERROR]”message to display”)</p>\n<p>输出信息</p>\n<ul>\n<li>SEND_ERROR ,产生错误，生成过程被跳过。</li>\n<li>STATUS ,输出前缀为1的信息。</li>\n<li>FATAL_ERROR,立即终止所有的cmake过程。</li>\n</ul>\n<h3 id=\"ADD-EXECUTABLE\"><a href=\"#ADD-EXECUTABLE\" class=\"headerlink\" title=\"ADD_EXECUTABLE\"></a>ADD_EXECUTABLE</h3><p>ADD_EXECUTABLE(hello,)</p>\n"},{"title":"Docker基本概念","date":"2020-10-09T06:46:02.000Z","_content":"\n## 镜像\n\n操作系统分内核空间和用户空间，对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个    \nroot 文件系统。\n\nDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、   \n用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n    \n### 分层存储\n\n因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。\n所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，\n由多层文件系统联合组成。\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，\n实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，\n在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n\n## 容器\n\n镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、\n启动、停止、删除、暂停等。\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、\n自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器\n封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。\n前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准\n备的存储层为 容器存储层。\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或\n者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。\n\n## 仓库\n\n镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker \nRegistry 就是这样的服务。\n一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件\n哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 \n来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。\n仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件\n名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。","source":"_posts/Docker基本概念.md","raw":"---\ntitle: Docker基本概念\ndate: 2020-10-09 14:46:02\ncategories: 常用工具\ntags: \n- docker\n---\n\n## 镜像\n\n操作系统分内核空间和用户空间，对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个    \nroot 文件系统。\n\nDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、   \n用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n    \n### 分层存储\n\n因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。\n所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，\n由多层文件系统联合组成。\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，\n实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，\n在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n\n## 容器\n\n镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、\n启动、停止、删除、暂停等。\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、\n自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器\n封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。\n前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准\n备的存储层为 容器存储层。\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或\n者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。\n\n## 仓库\n\n镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker \nRegistry 就是这样的服务。\n一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件\n哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 \n来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。\n仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件\n名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。","slug":"Docker基本概念","published":1,"updated":"2021-11-02T07:56:45.908Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblb0001zsw7fg2dacyr","content":"<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><p>操作系统分内核空间和用户空间，对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个<br>root 文件系统。</p>\n<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、<br>用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<h3 id=\"分层存储\"><a href=\"#分层存储\" class=\"headerlink\" title=\"分层存储\"></a>分层存储</h3><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。<br>所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，<br>由多层文件系统联合组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，<br>实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，<br>在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、<br>启动、停止、删除、暂停等。<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、<br>自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器<br>封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。<br>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准<br>备的存储层为 容器存储层。<br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。<br>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或<br>者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。<br>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker<br>Registry 就是这样的服务。<br>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件<br>哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04<br>来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。<br>仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件<br>名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><p>操作系统分内核空间和用户空间，对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个<br>root 文件系统。</p>\n<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、<br>用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<h3 id=\"分层存储\"><a href=\"#分层存储\" class=\"headerlink\" title=\"分层存储\"></a>分层存储</h3><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。<br>所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，<br>由多层文件系统联合组成。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，<br>实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，<br>在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、<br>启动、停止、删除、暂停等。<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、<br>自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器<br>封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。<br>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准<br>备的存储层为 容器存储层。<br>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。<br>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或<br>者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。<br>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>\n<h2 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker<br>Registry 就是这样的服务。<br>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件<br>哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04<br>来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。<br>仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件<br>名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>\n"},{"title":"Hystrix 服务容错保护","date":"2020-10-22T05:28:30.000Z","_content":"## 简介\n\nSpring Cloud Hystrix 是Spring Cloud Netflix 子项目的核心组件之一，具有服务容错及线程隔离等一系列服务保护功能。\n\n在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统\n瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得\n不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。\n\n## 依赖\n\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n```\n\n## yml配置\n```\nserver:\n  port: 8401\nspring:\n  application:\n    name: hystrix-service\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n      defaultZone: http://localhost:8001/eureka/\nservice-url:\n  user-service: http://user-service\n\n```\n\n## 启动类上添加@EnableCircuitBreaker来开启Hystrix的断路器功能\n\n```\n@EnableCircuitBreaker\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class HystrixServiceApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HystrixServiceApplication.class, args);\n    }\n\n```\n\n## 功能\n\n@HystrixCommand中的常用参数\n\nfallbackMethod：指定服务降级处理方法；\nignoreExceptions：忽略某些异常，不发生服务降级；\ncommandKey：命令名称，用于区分不同的命令；\ngroupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；\nthreadPoolKey：线程池名称，用于划分线程池。\n\n### 服务降级\n\n方法上添加次注解\n\n```\n@HystrixCommand(fallbackMethod = \"getDefaultUser\")\n```\n\n### 异常忽略\n\n```\n@HystrixCommand(fallbackMethod = \"getDefaultUser2\", ignoreExceptions = {NullPointerException.class})\n```\n\n### 请求缓存\n\n当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。\n\n#### 相关注解\n\n- @CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；\n- @CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；\n- @CacheRemove：移除缓存，需要指定commandKey。\n\n#### 在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭\n\nRequest caching is not available. Maybe you need to initialize the HystrixRequestContext?\n\n使用过滤器解决\n\n```\n@Component\n@WebFilter(urlPatterns = \"/*\", asyncSupported = true)\npublic class HystrixRequestContextFilter implements Filter {\n    public static final Logger LOGGER = LoggerFactory.getLogger(HystrixRequestContextFilter.class);\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        try (HystrixRequestContext context = HystrixRequestContext.initializeContext()) {\n            filterChain.doFilter(servletRequest, servletResponse);\n        } catch (ServletException e) {\n            LOGGER.error(\"filter-error\",e);\n        }\n    }\n}\n```\n\n### 请求合并\n\n微服务系统中的服务间通信，需要通过远程调用来实现，随着调用次数越来越多，占用线程资源也会越来越多。Hystrix中提供了@HystrixCollapser用于合并请求，\n从而达到减少通信消耗及线程数量的效果。\n\n#### 常用属性\n\n- batchMethod：用于设置请求合并的方法；\n- collapserProperties：请求合并属性，用于控制实例属性，有很多；\n- timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求；\n\n\n## Hystrix全局配置\n\n```\nhystrix:\n  command: #用于控制HystrixCommand的行为\n    default:\n      execution:\n        isolation:\n          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD->线程池隔离策略(默认)，SEMAPHORE->信号量隔离策略\n          thread:\n            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理\n            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断\n            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断\n          timeout:\n            enabled: true #配置HystrixCommand的执行是否启用超时时间\n          semaphore:\n            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝\n      fallback:\n        enabled: true #用于控制是否启用服务降级\n      circuitBreaker: #用于控制HystrixCircuitBreaker的行为\n        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求\n        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝\n        forceOpen: false #强制打开断路器，拒绝所有请求\n        forceClosed: false #强制关闭断路器，接收所有请求\n      requestCache:\n        enabled: true #用于控制是否开启请求缓存\n  collapser: #用于控制HystrixCollapser的执行行为\n    default:\n      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数\n      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个\n      requestCache:\n        enabled: true #控制合并请求是否开启缓存\n  threadpool: #用于控制HystrixCommand执行所在线程池的行为\n    default:\n      coreSize: 10 #线程池的核心线程数\n      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝\n      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue\n      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数\n\n```\n\n## 实例配置\n\n```\nhystrix:\n  command:\n    HystrixComandKey: #将default换成HystrixComrnandKey\n      execution:\n        isolation:\n          strategy: THREAD\n  collapser:\n    HystrixCollapserKey: #将default换成HystrixCollapserKey\n      maxRequestsInBatch: 100\n  threadpool:\n    HystrixThreadPoolKey: #将default换成HystrixThreadPoolKey\n      coreSize: 10\n\n```\n\n\n","source":"_posts/Hystrix-服务容错保护.md","raw":"---\ntitle: hystrix 服务容错保护\ndate: 2020-10-22 13:28:30\ntags:\n- java\n- spring cloud\ncategories: java\n---\n## 简介\n\nSpring Cloud Hystrix 是Spring Cloud Netflix 子项目的核心组件之一，具有服务容错及线程隔离等一系列服务保护功能。\n\n在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统\n瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得\n不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。\n\n## 依赖\n\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n```\n\n## yml配置\n```\nserver:\n  port: 8401\nspring:\n  application:\n    name: hystrix-service\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n      defaultZone: http://localhost:8001/eureka/\nservice-url:\n  user-service: http://user-service\n\n```\n\n## 启动类上添加@EnableCircuitBreaker来开启Hystrix的断路器功能\n\n```\n@EnableCircuitBreaker\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class HystrixServiceApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HystrixServiceApplication.class, args);\n    }\n\n```\n\n## 功能\n\n@HystrixCommand中的常用参数\n\nfallbackMethod：指定服务降级处理方法；\nignoreExceptions：忽略某些异常，不发生服务降级；\ncommandKey：命令名称，用于区分不同的命令；\ngroupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；\nthreadPoolKey：线程池名称，用于划分线程池。\n\n### 服务降级\n\n方法上添加次注解\n\n```\n@HystrixCommand(fallbackMethod = \"getDefaultUser\")\n```\n\n### 异常忽略\n\n```\n@HystrixCommand(fallbackMethod = \"getDefaultUser2\", ignoreExceptions = {NullPointerException.class})\n```\n\n### 请求缓存\n\n当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。\n\n#### 相关注解\n\n- @CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；\n- @CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；\n- @CacheRemove：移除缓存，需要指定commandKey。\n\n#### 在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭\n\nRequest caching is not available. Maybe you need to initialize the HystrixRequestContext?\n\n使用过滤器解决\n\n```\n@Component\n@WebFilter(urlPatterns = \"/*\", asyncSupported = true)\npublic class HystrixRequestContextFilter implements Filter {\n    public static final Logger LOGGER = LoggerFactory.getLogger(HystrixRequestContextFilter.class);\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        try (HystrixRequestContext context = HystrixRequestContext.initializeContext()) {\n            filterChain.doFilter(servletRequest, servletResponse);\n        } catch (ServletException e) {\n            LOGGER.error(\"filter-error\",e);\n        }\n    }\n}\n```\n\n### 请求合并\n\n微服务系统中的服务间通信，需要通过远程调用来实现，随着调用次数越来越多，占用线程资源也会越来越多。Hystrix中提供了@HystrixCollapser用于合并请求，\n从而达到减少通信消耗及线程数量的效果。\n\n#### 常用属性\n\n- batchMethod：用于设置请求合并的方法；\n- collapserProperties：请求合并属性，用于控制实例属性，有很多；\n- timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求；\n\n\n## Hystrix全局配置\n\n```\nhystrix:\n  command: #用于控制HystrixCommand的行为\n    default:\n      execution:\n        isolation:\n          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD->线程池隔离策略(默认)，SEMAPHORE->信号量隔离策略\n          thread:\n            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理\n            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断\n            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断\n          timeout:\n            enabled: true #配置HystrixCommand的执行是否启用超时时间\n          semaphore:\n            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝\n      fallback:\n        enabled: true #用于控制是否启用服务降级\n      circuitBreaker: #用于控制HystrixCircuitBreaker的行为\n        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求\n        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝\n        forceOpen: false #强制打开断路器，拒绝所有请求\n        forceClosed: false #强制关闭断路器，接收所有请求\n      requestCache:\n        enabled: true #用于控制是否开启请求缓存\n  collapser: #用于控制HystrixCollapser的执行行为\n    default:\n      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数\n      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个\n      requestCache:\n        enabled: true #控制合并请求是否开启缓存\n  threadpool: #用于控制HystrixCommand执行所在线程池的行为\n    default:\n      coreSize: 10 #线程池的核心线程数\n      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝\n      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue\n      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数\n\n```\n\n## 实例配置\n\n```\nhystrix:\n  command:\n    HystrixComandKey: #将default换成HystrixComrnandKey\n      execution:\n        isolation:\n          strategy: THREAD\n  collapser:\n    HystrixCollapserKey: #将default换成HystrixCollapserKey\n      maxRequestsInBatch: 100\n  threadpool:\n    HystrixThreadPoolKey: #将default换成HystrixThreadPoolKey\n      coreSize: 10\n\n```\n\n\n","slug":"Hystrix-服务容错保护","published":1,"updated":"2021-11-02T07:56:45.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblg0004zsw7ejdkb8r1","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Spring Cloud Hystrix 是Spring Cloud Netflix 子项目的核心组件之一，具有服务容错及线程隔离等一系列服务保护功能。</p>\n<p>在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统<br>瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得<br>不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"yml配置\"><a href=\"#yml配置\" class=\"headerlink\" title=\"yml配置\"></a>yml配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: 8401</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: hystrix-service</span><br><span class=\"line\">eureka:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    register-with-eureka: true</span><br><span class=\"line\">    fetch-registry: true</span><br><span class=\"line\">    service-url:</span><br><span class=\"line\">      defaultZone: http://localhost:8001/eureka/</span><br><span class=\"line\">service-url:</span><br><span class=\"line\">  user-service: http://user-service</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动类上添加-EnableCircuitBreaker来开启Hystrix的断路器功能\"><a href=\"#启动类上添加-EnableCircuitBreaker来开启Hystrix的断路器功能\" class=\"headerlink\" title=\"启动类上添加@EnableCircuitBreaker来开启Hystrix的断路器功能\"></a>启动类上添加@EnableCircuitBreaker来开启Hystrix的断路器功能</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableCircuitBreaker</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class HystrixServiceApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(HystrixServiceApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><p>@HystrixCommand中的常用参数</p>\n<p>fallbackMethod：指定服务降级处理方法；<br>ignoreExceptions：忽略某些异常，不发生服务降级；<br>commandKey：命令名称，用于区分不同的命令；<br>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；<br>threadPoolKey：线程池名称，用于划分线程池。</p>\n<h3 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h3><p>方法上添加次注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@HystrixCommand(fallbackMethod = &quot;getDefaultUser&quot;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异常忽略\"><a href=\"#异常忽略\" class=\"headerlink\" title=\"异常忽略\"></a>异常忽略</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@HystrixCommand(fallbackMethod = &quot;getDefaultUser2&quot;, ignoreExceptions = &#123;NullPointerException.class&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求缓存\"><a href=\"#请求缓存\" class=\"headerlink\" title=\"请求缓存\"></a>请求缓存</h3><p>当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。</p>\n<h4 id=\"相关注解\"><a href=\"#相关注解\" class=\"headerlink\" title=\"相关注解\"></a>相关注解</h4><ul>\n<li>@CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</li>\n<li>@CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</li>\n<li>@CacheRemove：移除缓存，需要指定commandKey。</li>\n</ul>\n<h4 id=\"在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭\"><a href=\"#在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭\" class=\"headerlink\" title=\"在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭\"></a>在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭</h4><p>Request caching is not available. Maybe you need to initialize the HystrixRequestContext?</p>\n<p>使用过滤器解决</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@WebFilter(urlPatterns = &quot;/*&quot;, asyncSupported = true)</span><br><span class=\"line\">public class HystrixRequestContextFilter implements Filter &#123;</span><br><span class=\"line\">    public static final Logger LOGGER = LoggerFactory.getLogger(HystrixRequestContextFilter.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class=\"line\">        try (HystrixRequestContext context = HystrixRequestContext.initializeContext()) &#123;</span><br><span class=\"line\">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        &#125; catch (ServletException e) &#123;</span><br><span class=\"line\">            LOGGER.error(&quot;filter-error&quot;,e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求合并\"><a href=\"#请求合并\" class=\"headerlink\" title=\"请求合并\"></a>请求合并</h3><p>微服务系统中的服务间通信，需要通过远程调用来实现，随着调用次数越来越多，占用线程资源也会越来越多。Hystrix中提供了@HystrixCollapser用于合并请求，<br>从而达到减少通信消耗及线程数量的效果。</p>\n<h4 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h4><ul>\n<li>batchMethod：用于设置请求合并的方法；</li>\n<li>collapserProperties：请求合并属性，用于控制实例属性，有很多；</li>\n<li>timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求；</li>\n</ul>\n<h2 id=\"Hystrix全局配置\"><a href=\"#Hystrix全局配置\" class=\"headerlink\" title=\"Hystrix全局配置\"></a>Hystrix全局配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hystrix:</span><br><span class=\"line\">  command: #用于控制HystrixCommand的行为</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      execution:</span><br><span class=\"line\">        isolation:</span><br><span class=\"line\">          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略</span><br><span class=\"line\">          thread:</span><br><span class=\"line\">            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理</span><br><span class=\"line\">            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断</span><br><span class=\"line\">            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断</span><br><span class=\"line\">          timeout:</span><br><span class=\"line\">            enabled: true #配置HystrixCommand的执行是否启用超时时间</span><br><span class=\"line\">          semaphore:</span><br><span class=\"line\">            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝</span><br><span class=\"line\">      fallback:</span><br><span class=\"line\">        enabled: true #用于控制是否启用服务降级</span><br><span class=\"line\">      circuitBreaker: #用于控制HystrixCircuitBreaker的行为</span><br><span class=\"line\">        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求</span><br><span class=\"line\">        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝</span><br><span class=\"line\">        forceOpen: false #强制打开断路器，拒绝所有请求</span><br><span class=\"line\">        forceClosed: false #强制关闭断路器，接收所有请求</span><br><span class=\"line\">      requestCache:</span><br><span class=\"line\">        enabled: true #用于控制是否开启请求缓存</span><br><span class=\"line\">  collapser: #用于控制HystrixCollapser的执行行为</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数</span><br><span class=\"line\">      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个</span><br><span class=\"line\">      requestCache:</span><br><span class=\"line\">        enabled: true #控制合并请求是否开启缓存</span><br><span class=\"line\">  threadpool: #用于控制HystrixCommand执行所在线程池的行为</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      coreSize: 10 #线程池的核心线程数</span><br><span class=\"line\">      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝</span><br><span class=\"line\">      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue</span><br><span class=\"line\">      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实例配置\"><a href=\"#实例配置\" class=\"headerlink\" title=\"实例配置\"></a>实例配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hystrix:</span><br><span class=\"line\">  command:</span><br><span class=\"line\">    HystrixComandKey: #将default换成HystrixComrnandKey</span><br><span class=\"line\">      execution:</span><br><span class=\"line\">        isolation:</span><br><span class=\"line\">          strategy: THREAD</span><br><span class=\"line\">  collapser:</span><br><span class=\"line\">    HystrixCollapserKey: #将default换成HystrixCollapserKey</span><br><span class=\"line\">      maxRequestsInBatch: 100</span><br><span class=\"line\">  threadpool:</span><br><span class=\"line\">    HystrixThreadPoolKey: #将default换成HystrixThreadPoolKey</span><br><span class=\"line\">      coreSize: 10</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Spring Cloud Hystrix 是Spring Cloud Netflix 子项目的核心组件之一，具有服务容错及线程隔离等一系列服务保护功能。</p>\n<p>在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统<br>瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得<br>不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"yml配置\"><a href=\"#yml配置\" class=\"headerlink\" title=\"yml配置\"></a>yml配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: 8401</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: hystrix-service</span><br><span class=\"line\">eureka:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    register-with-eureka: true</span><br><span class=\"line\">    fetch-registry: true</span><br><span class=\"line\">    service-url:</span><br><span class=\"line\">      defaultZone: http://localhost:8001/eureka/</span><br><span class=\"line\">service-url:</span><br><span class=\"line\">  user-service: http://user-service</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动类上添加-EnableCircuitBreaker来开启Hystrix的断路器功能\"><a href=\"#启动类上添加-EnableCircuitBreaker来开启Hystrix的断路器功能\" class=\"headerlink\" title=\"启动类上添加@EnableCircuitBreaker来开启Hystrix的断路器功能\"></a>启动类上添加@EnableCircuitBreaker来开启Hystrix的断路器功能</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableCircuitBreaker</span><br><span class=\"line\">@EnableDiscoveryClient</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class HystrixServiceApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(HystrixServiceApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><p>@HystrixCommand中的常用参数</p>\n<p>fallbackMethod：指定服务降级处理方法；<br>ignoreExceptions：忽略某些异常，不发生服务降级；<br>commandKey：命令名称，用于区分不同的命令；<br>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；<br>threadPoolKey：线程池名称，用于划分线程池。</p>\n<h3 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h3><p>方法上添加次注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@HystrixCommand(fallbackMethod = &quot;getDefaultUser&quot;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异常忽略\"><a href=\"#异常忽略\" class=\"headerlink\" title=\"异常忽略\"></a>异常忽略</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@HystrixCommand(fallbackMethod = &quot;getDefaultUser2&quot;, ignoreExceptions = &#123;NullPointerException.class&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求缓存\"><a href=\"#请求缓存\" class=\"headerlink\" title=\"请求缓存\"></a>请求缓存</h3><p>当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。</p>\n<h4 id=\"相关注解\"><a href=\"#相关注解\" class=\"headerlink\" title=\"相关注解\"></a>相关注解</h4><ul>\n<li>@CacheResult：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</li>\n<li>@CacheKey：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</li>\n<li>@CacheRemove：移除缓存，需要指定commandKey。</li>\n</ul>\n<h4 id=\"在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭\"><a href=\"#在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭\" class=\"headerlink\" title=\"在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭\"></a>在缓存使用过程中，我们需要在每次使用缓存的请求前后对HystrixRequestContext进行初始化和关闭</h4><p>Request caching is not available. Maybe you need to initialize the HystrixRequestContext?</p>\n<p>使用过滤器解决</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@WebFilter(urlPatterns = &quot;/*&quot;, asyncSupported = true)</span><br><span class=\"line\">public class HystrixRequestContextFilter implements Filter &#123;</span><br><span class=\"line\">    public static final Logger LOGGER = LoggerFactory.getLogger(HystrixRequestContextFilter.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class=\"line\">        try (HystrixRequestContext context = HystrixRequestContext.initializeContext()) &#123;</span><br><span class=\"line\">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class=\"line\">        &#125; catch (ServletException e) &#123;</span><br><span class=\"line\">            LOGGER.error(&quot;filter-error&quot;,e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"请求合并\"><a href=\"#请求合并\" class=\"headerlink\" title=\"请求合并\"></a>请求合并</h3><p>微服务系统中的服务间通信，需要通过远程调用来实现，随着调用次数越来越多，占用线程资源也会越来越多。Hystrix中提供了@HystrixCollapser用于合并请求，<br>从而达到减少通信消耗及线程数量的效果。</p>\n<h4 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h4><ul>\n<li>batchMethod：用于设置请求合并的方法；</li>\n<li>collapserProperties：请求合并属性，用于控制实例属性，有很多；</li>\n<li>timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求；</li>\n</ul>\n<h2 id=\"Hystrix全局配置\"><a href=\"#Hystrix全局配置\" class=\"headerlink\" title=\"Hystrix全局配置\"></a>Hystrix全局配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hystrix:</span><br><span class=\"line\">  command: #用于控制HystrixCommand的行为</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      execution:</span><br><span class=\"line\">        isolation:</span><br><span class=\"line\">          strategy: THREAD #控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略</span><br><span class=\"line\">          thread:</span><br><span class=\"line\">            timeoutInMilliseconds: 1000 #配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理</span><br><span class=\"line\">            interruptOnTimeout: true #配置HystrixCommand执行超时的时候是否要中断</span><br><span class=\"line\">            interruptOnCancel: true #配置HystrixCommand执行被取消的时候是否要中断</span><br><span class=\"line\">          timeout:</span><br><span class=\"line\">            enabled: true #配置HystrixCommand的执行是否启用超时时间</span><br><span class=\"line\">          semaphore:</span><br><span class=\"line\">            maxConcurrentRequests: 10 #当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝</span><br><span class=\"line\">      fallback:</span><br><span class=\"line\">        enabled: true #用于控制是否启用服务降级</span><br><span class=\"line\">      circuitBreaker: #用于控制HystrixCircuitBreaker的行为</span><br><span class=\"line\">        enabled: true #用于控制断路器是否跟踪健康状况以及熔断请求</span><br><span class=\"line\">        requestVolumeThreshold: 20 #超过该请求数的请求会被拒绝</span><br><span class=\"line\">        forceOpen: false #强制打开断路器，拒绝所有请求</span><br><span class=\"line\">        forceClosed: false #强制关闭断路器，接收所有请求</span><br><span class=\"line\">      requestCache:</span><br><span class=\"line\">        enabled: true #用于控制是否开启请求缓存</span><br><span class=\"line\">  collapser: #用于控制HystrixCollapser的执行行为</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      maxRequestsInBatch: 100 #控制一次合并请求合并的最大请求数</span><br><span class=\"line\">      timerDelayinMilliseconds: 10 #控制多少毫秒内的请求会被合并成一个</span><br><span class=\"line\">      requestCache:</span><br><span class=\"line\">        enabled: true #控制合并请求是否开启缓存</span><br><span class=\"line\">  threadpool: #用于控制HystrixCommand执行所在线程池的行为</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      coreSize: 10 #线程池的核心线程数</span><br><span class=\"line\">      maximumSize: 10 #线程池的最大线程数，超过该线程数的请求会被拒绝</span><br><span class=\"line\">      maxQueueSize: -1 #用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue</span><br><span class=\"line\">      queueSizeRejectionThreshold: 5 #用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实例配置\"><a href=\"#实例配置\" class=\"headerlink\" title=\"实例配置\"></a>实例配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hystrix:</span><br><span class=\"line\">  command:</span><br><span class=\"line\">    HystrixComandKey: #将default换成HystrixComrnandKey</span><br><span class=\"line\">      execution:</span><br><span class=\"line\">        isolation:</span><br><span class=\"line\">          strategy: THREAD</span><br><span class=\"line\">  collapser:</span><br><span class=\"line\">    HystrixCollapserKey: #将default换成HystrixCollapserKey</span><br><span class=\"line\">      maxRequestsInBatch: 100</span><br><span class=\"line\">  threadpool:</span><br><span class=\"line\">    HystrixThreadPoolKey: #将default换成HystrixThreadPoolKey</span><br><span class=\"line\">      coreSize: 10</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Kotlin","date":"2020-10-10T06:58:17.000Z","_content":"\n## 函数\n\nfun methodName(param1: Int, param2: Int): Int {\n      return 0\n}\n\n单行代码函数的语法糖：fun methodName(param1: Int, param2: Int) = 0\n直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。\nreturn关键字也可以省略，等号足以表达返回值的意思\n\n### 逻辑控制\n\n### if语句返回值\n```\nfun largerNumber(num1: Int, num2: Int): Int {\n    return if (num1 > num2) {\n        num1\n    } else {\n        num2\n    }\n}\n\n//=>\n\nfun largerNumber(num1: Int, num2: Int) = if (num1 > num2) num1 else num2\n\n```\n### when 条件语句\n\n当需要判断的条件非常多的时候，可以考虑使用when语句来替代if语句。\n\n```\nfun getScore(name: String) = when (name) {\n    \"Tom\" -> 86\n    \"Jim\" -> 77\n    \"Jack\" -> 95\n    \"Lily\" -> 100\n    else -> 0\n}\n```\nwhen语句还允许进行类型匹配。\n```\nfun checkNumber(num: Number) {\n    when (num) {\n        is Int -> println(\"number is Int\")\n        is Double -> println(\"number is Double\")\n        else -> println(\"number not support\")\n    }\n}\n```\n\n### 循环\nval range = 0..10\n表示创建了一个0到10的区间，并且两端都是闭区间，这意味着0到10这两个端点都是包含在区间中的，用数学的方式表达出来就是[0, 10]\n\nval range = 0 until 10\n表示创建了一个0到10的左闭右开区间，它的数学表达方式是[0, 10)\n\n```\nfun main() {\n    for (i in 0..10) {\n        println(i)\n    }\n}\n\n```\n跳过其中的一些元素，可以使用step关键字\n```\nfun main() {\n    for (i in 0 until 10 step 2) {\n        println(i)\n    }\n}\n```\n降序的区间，可以使用downTo关键字\n```\nfun main() {\n    for (i in 10 downTo 1) {\n        println(i)\n    }\n}\n```\n\n## 类\n\n```\nclass Person {\n    var name = \"\"\n    var age = 0\n\n    fun eat() {\n        println(name + \" is eating. He is \" + age + \" years old.\")\n    }\n}\n\n```\n创建对象\n\n```\nfun main() {\n    val p = Person()\n    p.name = \"Jack\"\n    p.age = 19\n    p.eat()\n}\n\n```\nKotlin类可以被继承，需要主动声明open关键字\n```\nopen class Person {\n    …\n}\n\n要让另一个类去继承Person类，则需要使用冒号关键字：\n\nclass Student : Person() {\n    var sno = \"\"\n    var grade = 0\n}\n```\n\n## 接口\n\n```\ninterface Study {\n    fun readBooks()\n    fun doHomework()\n}\n\nKotlin中实现接口的关键字变量了冒号，和继承使用的是同样的关键字：\n\nclass Student(val name: String, val age: Int) : Study {\n    override fun readBooks() {\n        println(name + \" is reading.\")\n    }\n    override fun doHomework() {\n        println(name + \" is doing homework.\")\n    }\n}\n```\n\n### 数据类\ndata关键字可以定义一个数据类\n```\ndata class Cellphone(val brand: String, val price: Double)\n\n```\nKotlin会根据数据类的主构造函数中的参数将equals()、hashCode()、toString()等固定且无实际逻辑意义的方法自动生成，从而大大简少了开发的工作量。\n\n### 单例类\nobject关键字可以定义一个单例类\n```\nobject Singleton {\n    fun singletonTest() {\n        println(\"singletonTest is called.\")\n    }\n}\n\n```\n调用单例类中的函数比较类似于Java中静态方法的调用方式\nSingleton.singletonTest()\n\n## Lambda\n\n### 集合\n\n始化一个集合\n\n```\nval list = listOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\", \"Grape\")\nval set = setOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\", \"Grape\")\nval map = mapOf(\"Apple\" to 1, \"Banana\" to 2, \"Orange\" to 3, \"Pear\" to 4, \"Grape\" to 5)\n```\n\nLambda表达式的语法结构：\n{参数名1: 参数类型, 参数名2: 参数类型 -> 函数体}\n\n首先最外层是一对大括号，如果有参数传入到Lambda表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个->符号，表示参数列表的结束以及函数体的开\n始，函数体中可以编写任意行代码，并且最后一行代码会自动作为Lambda表达式的返回值。\n\n集合中的map函数是最常用的一种函数式API，它用于将集合中的每个元素都映射成一个另外的值，映射的规则在Lambda表达式中指定，最终生成一个新的集合。比如，\n这里我们希望让所有的水果名都变成大写模式，就可以这样写：\n\nfun main() {\n    val list = listOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\", \"Grape\", \"Watermelon\")\n    val newList = list.map({ fruit: String -> fruit.toUpperCase() })\n    for (fruit in newList) {\n        println(fruit)\n    }\n}\n- 当Lambda参数是函数的最后一个参数时，可以将Lambda表达式移到函数括号的外面。\n\n- 如果Lambda参数是函数的唯一一个参数的话，还可以将函数的括号省略。\n\n- 由于Kotlin拥有出色的类型推导机制，Lambda表达式中的参数列表其实在大多数情况下也`不必声明参数类型`。\n\n- 当Lambda表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用`it`关键字来代替。\n\n因此，Lambda表达式的写法可以进一步简化成如下方式：\n\nval newList = list.map { it.toUpperCase() }\n\n### 空指针\n\nKotlin中引入了一个可空类型系统的概念，它利用编译时判空检查的机制几乎杜绝了空指针异常。\n\n```\nfun doStudy(study: Study) {\n    study.readBooks()\n    study.doHomework()\n}\n\n```\n\n这段代码实际上它是没有空指针风险的，因为Kotlin默认所有的参数和变量都不可为空，所以这里传入的Study参数也一定不会为空，可以放心地调用它的任何函数。\n\nKotlin提供了另外一套可为空的类型系统，就是在类名的后面加上一个问号。比如，Int表示不可为空的整型，而Int?就表示可为空的整型；String表示不可为空的字符串，而String?就表示可为空的字符串。\n\n使用可为空的类型系统时，需要在编译时期就把所有的空指针异常都处理掉才行。\n\n\nKotlin提供了一系列的辅助工具，使开发者能够更轻松地进行判空处理。\n\n\n?. 操作符表示当对象不为空时正常调用相应的方法，当对象为空时则什么都不做。比如：\n\nif (a != null) {\n    a.doSomething()\n}\n\n这段代码使用?.操作符就可以简化成：\n\na?.doSomething()\n\n?: 操作符表示如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。比如：\n\nval c = if (a ! = null) {\n    a\n} else {\n    b\n}\n\n这段代码的逻辑使用?:操作符就可以简化成：\n\nval c = a ?: b\n\n### 字符串\n\nKotlin中字符串内嵌表达式的语法规则如下：\n\n\"hello, ${obj.name}. nice to meet you!\"\n\n当表达式中仅有一个变量的时候，还可以将两边的大括号省略：\n\n\"hello, $name. nice to meet you!\"\n\n### 参数默认值\n\n```\nfun printParams(num: Int, str: String = \"hello\") {\n    println(\"num is $num , str is $str\")\n}\n\n```","source":"_posts/Kotlin.md","raw":"---\ntitle: Kotlin\ndate: 2020-10-10 14:58:17\ncategories: android\ntags: \n- android\n---\n\n## 函数\n\nfun methodName(param1: Int, param2: Int): Int {\n      return 0\n}\n\n单行代码函数的语法糖：fun methodName(param1: Int, param2: Int) = 0\n直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。\nreturn关键字也可以省略，等号足以表达返回值的意思\n\n### 逻辑控制\n\n### if语句返回值\n```\nfun largerNumber(num1: Int, num2: Int): Int {\n    return if (num1 > num2) {\n        num1\n    } else {\n        num2\n    }\n}\n\n//=>\n\nfun largerNumber(num1: Int, num2: Int) = if (num1 > num2) num1 else num2\n\n```\n### when 条件语句\n\n当需要判断的条件非常多的时候，可以考虑使用when语句来替代if语句。\n\n```\nfun getScore(name: String) = when (name) {\n    \"Tom\" -> 86\n    \"Jim\" -> 77\n    \"Jack\" -> 95\n    \"Lily\" -> 100\n    else -> 0\n}\n```\nwhen语句还允许进行类型匹配。\n```\nfun checkNumber(num: Number) {\n    when (num) {\n        is Int -> println(\"number is Int\")\n        is Double -> println(\"number is Double\")\n        else -> println(\"number not support\")\n    }\n}\n```\n\n### 循环\nval range = 0..10\n表示创建了一个0到10的区间，并且两端都是闭区间，这意味着0到10这两个端点都是包含在区间中的，用数学的方式表达出来就是[0, 10]\n\nval range = 0 until 10\n表示创建了一个0到10的左闭右开区间，它的数学表达方式是[0, 10)\n\n```\nfun main() {\n    for (i in 0..10) {\n        println(i)\n    }\n}\n\n```\n跳过其中的一些元素，可以使用step关键字\n```\nfun main() {\n    for (i in 0 until 10 step 2) {\n        println(i)\n    }\n}\n```\n降序的区间，可以使用downTo关键字\n```\nfun main() {\n    for (i in 10 downTo 1) {\n        println(i)\n    }\n}\n```\n\n## 类\n\n```\nclass Person {\n    var name = \"\"\n    var age = 0\n\n    fun eat() {\n        println(name + \" is eating. He is \" + age + \" years old.\")\n    }\n}\n\n```\n创建对象\n\n```\nfun main() {\n    val p = Person()\n    p.name = \"Jack\"\n    p.age = 19\n    p.eat()\n}\n\n```\nKotlin类可以被继承，需要主动声明open关键字\n```\nopen class Person {\n    …\n}\n\n要让另一个类去继承Person类，则需要使用冒号关键字：\n\nclass Student : Person() {\n    var sno = \"\"\n    var grade = 0\n}\n```\n\n## 接口\n\n```\ninterface Study {\n    fun readBooks()\n    fun doHomework()\n}\n\nKotlin中实现接口的关键字变量了冒号，和继承使用的是同样的关键字：\n\nclass Student(val name: String, val age: Int) : Study {\n    override fun readBooks() {\n        println(name + \" is reading.\")\n    }\n    override fun doHomework() {\n        println(name + \" is doing homework.\")\n    }\n}\n```\n\n### 数据类\ndata关键字可以定义一个数据类\n```\ndata class Cellphone(val brand: String, val price: Double)\n\n```\nKotlin会根据数据类的主构造函数中的参数将equals()、hashCode()、toString()等固定且无实际逻辑意义的方法自动生成，从而大大简少了开发的工作量。\n\n### 单例类\nobject关键字可以定义一个单例类\n```\nobject Singleton {\n    fun singletonTest() {\n        println(\"singletonTest is called.\")\n    }\n}\n\n```\n调用单例类中的函数比较类似于Java中静态方法的调用方式\nSingleton.singletonTest()\n\n## Lambda\n\n### 集合\n\n始化一个集合\n\n```\nval list = listOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\", \"Grape\")\nval set = setOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\", \"Grape\")\nval map = mapOf(\"Apple\" to 1, \"Banana\" to 2, \"Orange\" to 3, \"Pear\" to 4, \"Grape\" to 5)\n```\n\nLambda表达式的语法结构：\n{参数名1: 参数类型, 参数名2: 参数类型 -> 函数体}\n\n首先最外层是一对大括号，如果有参数传入到Lambda表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个->符号，表示参数列表的结束以及函数体的开\n始，函数体中可以编写任意行代码，并且最后一行代码会自动作为Lambda表达式的返回值。\n\n集合中的map函数是最常用的一种函数式API，它用于将集合中的每个元素都映射成一个另外的值，映射的规则在Lambda表达式中指定，最终生成一个新的集合。比如，\n这里我们希望让所有的水果名都变成大写模式，就可以这样写：\n\nfun main() {\n    val list = listOf(\"Apple\", \"Banana\", \"Orange\", \"Pear\", \"Grape\", \"Watermelon\")\n    val newList = list.map({ fruit: String -> fruit.toUpperCase() })\n    for (fruit in newList) {\n        println(fruit)\n    }\n}\n- 当Lambda参数是函数的最后一个参数时，可以将Lambda表达式移到函数括号的外面。\n\n- 如果Lambda参数是函数的唯一一个参数的话，还可以将函数的括号省略。\n\n- 由于Kotlin拥有出色的类型推导机制，Lambda表达式中的参数列表其实在大多数情况下也`不必声明参数类型`。\n\n- 当Lambda表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用`it`关键字来代替。\n\n因此，Lambda表达式的写法可以进一步简化成如下方式：\n\nval newList = list.map { it.toUpperCase() }\n\n### 空指针\n\nKotlin中引入了一个可空类型系统的概念，它利用编译时判空检查的机制几乎杜绝了空指针异常。\n\n```\nfun doStudy(study: Study) {\n    study.readBooks()\n    study.doHomework()\n}\n\n```\n\n这段代码实际上它是没有空指针风险的，因为Kotlin默认所有的参数和变量都不可为空，所以这里传入的Study参数也一定不会为空，可以放心地调用它的任何函数。\n\nKotlin提供了另外一套可为空的类型系统，就是在类名的后面加上一个问号。比如，Int表示不可为空的整型，而Int?就表示可为空的整型；String表示不可为空的字符串，而String?就表示可为空的字符串。\n\n使用可为空的类型系统时，需要在编译时期就把所有的空指针异常都处理掉才行。\n\n\nKotlin提供了一系列的辅助工具，使开发者能够更轻松地进行判空处理。\n\n\n?. 操作符表示当对象不为空时正常调用相应的方法，当对象为空时则什么都不做。比如：\n\nif (a != null) {\n    a.doSomething()\n}\n\n这段代码使用?.操作符就可以简化成：\n\na?.doSomething()\n\n?: 操作符表示如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。比如：\n\nval c = if (a ! = null) {\n    a\n} else {\n    b\n}\n\n这段代码的逻辑使用?:操作符就可以简化成：\n\nval c = a ?: b\n\n### 字符串\n\nKotlin中字符串内嵌表达式的语法规则如下：\n\n\"hello, ${obj.name}. nice to meet you!\"\n\n当表达式中仅有一个变量的时候，还可以将两边的大括号省略：\n\n\"hello, $name. nice to meet you!\"\n\n### 参数默认值\n\n```\nfun printParams(num: Int, str: String = \"hello\") {\n    println(\"num is $num , str is $str\")\n}\n\n```","slug":"Kotlin","published":1,"updated":"2021-11-02T07:56:45.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblh0005zsw7bqpt4ob1","content":"<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>fun methodName(param1: Int, param2: Int): Int {<br>      return 0<br>}</p>\n<p>单行代码函数的语法糖：fun methodName(param1: Int, param2: Int) = 0<br>直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。<br>return关键字也可以省略，等号足以表达返回值的意思</p>\n<h3 id=\"逻辑控制\"><a href=\"#逻辑控制\" class=\"headerlink\" title=\"逻辑控制\"></a>逻辑控制</h3><h3 id=\"if语句返回值\"><a href=\"#if语句返回值\" class=\"headerlink\" title=\"if语句返回值\"></a>if语句返回值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun largerNumber(num1: Int, num2: Int): Int &#123;</span><br><span class=\"line\">    return if (num1 &gt; num2) &#123;</span><br><span class=\"line\">        num1</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        num2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//=&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">fun largerNumber(num1: Int, num2: Int) = if (num1 &gt; num2) num1 else num2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"when-条件语句\"><a href=\"#when-条件语句\" class=\"headerlink\" title=\"when 条件语句\"></a>when 条件语句</h3><p>当需要判断的条件非常多的时候，可以考虑使用when语句来替代if语句。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun getScore(name: String) = when (name) &#123;</span><br><span class=\"line\">    &quot;Tom&quot; -&gt; 86</span><br><span class=\"line\">    &quot;Jim&quot; -&gt; 77</span><br><span class=\"line\">    &quot;Jack&quot; -&gt; 95</span><br><span class=\"line\">    &quot;Lily&quot; -&gt; 100</span><br><span class=\"line\">    else -&gt; 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>when语句还允许进行类型匹配。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun checkNumber(num: Number) &#123;</span><br><span class=\"line\">    when (num) &#123;</span><br><span class=\"line\">        is Int -&gt; println(&quot;number is Int&quot;)</span><br><span class=\"line\">        is Double -&gt; println(&quot;number is Double&quot;)</span><br><span class=\"line\">        else -&gt; println(&quot;number not support&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>val range = 0..10<br>表示创建了一个0到10的区间，并且两端都是闭区间，这意味着0到10这两个端点都是包含在区间中的，用数学的方式表达出来就是[0, 10]</p>\n<p>val range = 0 until 10<br>表示创建了一个0到10的左闭右开区间，它的数学表达方式是[0, 10)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun main() &#123;</span><br><span class=\"line\">    for (i in 0..10) &#123;</span><br><span class=\"line\">        println(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>跳过其中的一些元素，可以使用step关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun main() &#123;</span><br><span class=\"line\">    for (i in 0 until 10 step 2) &#123;</span><br><span class=\"line\">        println(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>降序的区间，可以使用downTo关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun main() &#123;</span><br><span class=\"line\">    for (i in 10 downTo 1) &#123;</span><br><span class=\"line\">        println(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    var name = &quot;&quot;</span><br><span class=\"line\">    var age = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    fun eat() &#123;</span><br><span class=\"line\">        println(name + &quot; is eating. He is &quot; + age + &quot; years old.&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>创建对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun main() &#123;</span><br><span class=\"line\">    val p = Person()</span><br><span class=\"line\">    p.name = &quot;Jack&quot;</span><br><span class=\"line\">    p.age = 19</span><br><span class=\"line\">    p.eat()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Kotlin类可以被继承，需要主动声明open关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open class Person &#123;</span><br><span class=\"line\">    …</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">要让另一个类去继承Person类，则需要使用冒号关键字：</span><br><span class=\"line\"></span><br><span class=\"line\">class Student : Person() &#123;</span><br><span class=\"line\">    var sno = &quot;&quot;</span><br><span class=\"line\">    var grade = 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Study &#123;</span><br><span class=\"line\">    fun readBooks()</span><br><span class=\"line\">    fun doHomework()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Kotlin中实现接口的关键字变量了冒号，和继承使用的是同样的关键字：</span><br><span class=\"line\"></span><br><span class=\"line\">class Student(val name: String, val age: Int) : Study &#123;</span><br><span class=\"line\">    override fun readBooks() &#123;</span><br><span class=\"line\">        println(name + &quot; is reading.&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    override fun doHomework() &#123;</span><br><span class=\"line\">        println(name + &quot; is doing homework.&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据类\"><a href=\"#数据类\" class=\"headerlink\" title=\"数据类\"></a>数据类</h3><p>data关键字可以定义一个数据类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data class Cellphone(val brand: String, val price: Double)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Kotlin会根据数据类的主构造函数中的参数将equals()、hashCode()、toString()等固定且无实际逻辑意义的方法自动生成，从而大大简少了开发的工作量。</p>\n<h3 id=\"单例类\"><a href=\"#单例类\" class=\"headerlink\" title=\"单例类\"></a>单例类</h3><p>object关键字可以定义一个单例类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object Singleton &#123;</span><br><span class=\"line\">    fun singletonTest() &#123;</span><br><span class=\"line\">        println(&quot;singletonTest is called.&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>调用单例类中的函数比较类似于Java中静态方法的调用方式<br>Singleton.singletonTest()</p>\n<h2 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h2><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>始化一个集合</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)</span><br><span class=\"line\">val set = setOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)</span><br><span class=\"line\">val map = mapOf(&quot;Apple&quot; to 1, &quot;Banana&quot; to 2, &quot;Orange&quot; to 3, &quot;Pear&quot; to 4, &quot;Grape&quot; to 5)</span><br></pre></td></tr></table></figure>\n\n<p>Lambda表达式的语法结构：<br>{参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体}</p>\n<p>首先最外层是一对大括号，如果有参数传入到Lambda表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个-&gt;符号，表示参数列表的结束以及函数体的开<br>始，函数体中可以编写任意行代码，并且最后一行代码会自动作为Lambda表达式的返回值。</p>\n<p>集合中的map函数是最常用的一种函数式API，它用于将集合中的每个元素都映射成一个另外的值，映射的规则在Lambda表达式中指定，最终生成一个新的集合。比如，<br>这里我们希望让所有的水果名都变成大写模式，就可以这样写：</p>\n<p>fun main() {<br>    val list = listOf(“Apple”, “Banana”, “Orange”, “Pear”, “Grape”, “Watermelon”)<br>    val newList = list.map({ fruit: String -&gt; fruit.toUpperCase() })<br>    for (fruit in newList) {<br>        println(fruit)<br>    }<br>}</p>\n<ul>\n<li><p>当Lambda参数是函数的最后一个参数时，可以将Lambda表达式移到函数括号的外面。</p>\n</li>\n<li><p>如果Lambda参数是函数的唯一一个参数的话，还可以将函数的括号省略。</p>\n</li>\n<li><p>由于Kotlin拥有出色的类型推导机制，Lambda表达式中的参数列表其实在大多数情况下也<code>不必声明参数类型</code>。</p>\n</li>\n<li><p>当Lambda表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用<code>it</code>关键字来代替。</p>\n</li>\n</ul>\n<p>因此，Lambda表达式的写法可以进一步简化成如下方式：</p>\n<p>val newList = list.map { it.toUpperCase() }</p>\n<h3 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h3><p>Kotlin中引入了一个可空类型系统的概念，它利用编译时判空检查的机制几乎杜绝了空指针异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun doStudy(study: Study) &#123;</span><br><span class=\"line\">    study.readBooks()</span><br><span class=\"line\">    study.doHomework()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码实际上它是没有空指针风险的，因为Kotlin默认所有的参数和变量都不可为空，所以这里传入的Study参数也一定不会为空，可以放心地调用它的任何函数。</p>\n<p>Kotlin提供了另外一套可为空的类型系统，就是在类名的后面加上一个问号。比如，Int表示不可为空的整型，而Int?就表示可为空的整型；String表示不可为空的字符串，而String?就表示可为空的字符串。</p>\n<p>使用可为空的类型系统时，需要在编译时期就把所有的空指针异常都处理掉才行。</p>\n<p>Kotlin提供了一系列的辅助工具，使开发者能够更轻松地进行判空处理。</p>\n<p>?. 操作符表示当对象不为空时正常调用相应的方法，当对象为空时则什么都不做。比如：</p>\n<p>if (a != null) {<br>    a.doSomething()<br>}</p>\n<p>这段代码使用?.操作符就可以简化成：</p>\n<p>a?.doSomething()</p>\n<p>?: 操作符表示如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。比如：</p>\n<p>val c = if (a ! = null) {<br>    a<br>} else {<br>    b<br>}</p>\n<p>这段代码的逻辑使用?:操作符就可以简化成：</p>\n<p>val c = a ?: b</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>Kotlin中字符串内嵌表达式的语法规则如下：</p>\n<p>“hello, ${obj.name}. nice to meet you!”</p>\n<p>当表达式中仅有一个变量的时候，还可以将两边的大括号省略：</p>\n<p>“hello, $name. nice to meet you!”</p>\n<h3 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun printParams(num: Int, str: String = &quot;hello&quot;) &#123;</span><br><span class=\"line\">    println(&quot;num is $num , str is $str&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>fun methodName(param1: Int, param2: Int): Int {<br>      return 0<br>}</p>\n<p>单行代码函数的语法糖：fun methodName(param1: Int, param2: Int) = 0<br>直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。<br>return关键字也可以省略，等号足以表达返回值的意思</p>\n<h3 id=\"逻辑控制\"><a href=\"#逻辑控制\" class=\"headerlink\" title=\"逻辑控制\"></a>逻辑控制</h3><h3 id=\"if语句返回值\"><a href=\"#if语句返回值\" class=\"headerlink\" title=\"if语句返回值\"></a>if语句返回值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun largerNumber(num1: Int, num2: Int): Int &#123;</span><br><span class=\"line\">    return if (num1 &gt; num2) &#123;</span><br><span class=\"line\">        num1</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        num2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//=&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">fun largerNumber(num1: Int, num2: Int) = if (num1 &gt; num2) num1 else num2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"when-条件语句\"><a href=\"#when-条件语句\" class=\"headerlink\" title=\"when 条件语句\"></a>when 条件语句</h3><p>当需要判断的条件非常多的时候，可以考虑使用when语句来替代if语句。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun getScore(name: String) = when (name) &#123;</span><br><span class=\"line\">    &quot;Tom&quot; -&gt; 86</span><br><span class=\"line\">    &quot;Jim&quot; -&gt; 77</span><br><span class=\"line\">    &quot;Jack&quot; -&gt; 95</span><br><span class=\"line\">    &quot;Lily&quot; -&gt; 100</span><br><span class=\"line\">    else -&gt; 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>when语句还允许进行类型匹配。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun checkNumber(num: Number) &#123;</span><br><span class=\"line\">    when (num) &#123;</span><br><span class=\"line\">        is Int -&gt; println(&quot;number is Int&quot;)</span><br><span class=\"line\">        is Double -&gt; println(&quot;number is Double&quot;)</span><br><span class=\"line\">        else -&gt; println(&quot;number not support&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>val range = 0..10<br>表示创建了一个0到10的区间，并且两端都是闭区间，这意味着0到10这两个端点都是包含在区间中的，用数学的方式表达出来就是[0, 10]</p>\n<p>val range = 0 until 10<br>表示创建了一个0到10的左闭右开区间，它的数学表达方式是[0, 10)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun main() &#123;</span><br><span class=\"line\">    for (i in 0..10) &#123;</span><br><span class=\"line\">        println(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>跳过其中的一些元素，可以使用step关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun main() &#123;</span><br><span class=\"line\">    for (i in 0 until 10 step 2) &#123;</span><br><span class=\"line\">        println(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>降序的区间，可以使用downTo关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun main() &#123;</span><br><span class=\"line\">    for (i in 10 downTo 1) &#123;</span><br><span class=\"line\">        println(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    var name = &quot;&quot;</span><br><span class=\"line\">    var age = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    fun eat() &#123;</span><br><span class=\"line\">        println(name + &quot; is eating. He is &quot; + age + &quot; years old.&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>创建对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun main() &#123;</span><br><span class=\"line\">    val p = Person()</span><br><span class=\"line\">    p.name = &quot;Jack&quot;</span><br><span class=\"line\">    p.age = 19</span><br><span class=\"line\">    p.eat()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Kotlin类可以被继承，需要主动声明open关键字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open class Person &#123;</span><br><span class=\"line\">    …</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">要让另一个类去继承Person类，则需要使用冒号关键字：</span><br><span class=\"line\"></span><br><span class=\"line\">class Student : Person() &#123;</span><br><span class=\"line\">    var sno = &quot;&quot;</span><br><span class=\"line\">    var grade = 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Study &#123;</span><br><span class=\"line\">    fun readBooks()</span><br><span class=\"line\">    fun doHomework()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Kotlin中实现接口的关键字变量了冒号，和继承使用的是同样的关键字：</span><br><span class=\"line\"></span><br><span class=\"line\">class Student(val name: String, val age: Int) : Study &#123;</span><br><span class=\"line\">    override fun readBooks() &#123;</span><br><span class=\"line\">        println(name + &quot; is reading.&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    override fun doHomework() &#123;</span><br><span class=\"line\">        println(name + &quot; is doing homework.&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据类\"><a href=\"#数据类\" class=\"headerlink\" title=\"数据类\"></a>数据类</h3><p>data关键字可以定义一个数据类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data class Cellphone(val brand: String, val price: Double)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Kotlin会根据数据类的主构造函数中的参数将equals()、hashCode()、toString()等固定且无实际逻辑意义的方法自动生成，从而大大简少了开发的工作量。</p>\n<h3 id=\"单例类\"><a href=\"#单例类\" class=\"headerlink\" title=\"单例类\"></a>单例类</h3><p>object关键字可以定义一个单例类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object Singleton &#123;</span><br><span class=\"line\">    fun singletonTest() &#123;</span><br><span class=\"line\">        println(&quot;singletonTest is called.&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>调用单例类中的函数比较类似于Java中静态方法的调用方式<br>Singleton.singletonTest()</p>\n<h2 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h2><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>始化一个集合</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)</span><br><span class=\"line\">val set = setOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)</span><br><span class=\"line\">val map = mapOf(&quot;Apple&quot; to 1, &quot;Banana&quot; to 2, &quot;Orange&quot; to 3, &quot;Pear&quot; to 4, &quot;Grape&quot; to 5)</span><br></pre></td></tr></table></figure>\n\n<p>Lambda表达式的语法结构：<br>{参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体}</p>\n<p>首先最外层是一对大括号，如果有参数传入到Lambda表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个-&gt;符号，表示参数列表的结束以及函数体的开<br>始，函数体中可以编写任意行代码，并且最后一行代码会自动作为Lambda表达式的返回值。</p>\n<p>集合中的map函数是最常用的一种函数式API，它用于将集合中的每个元素都映射成一个另外的值，映射的规则在Lambda表达式中指定，最终生成一个新的集合。比如，<br>这里我们希望让所有的水果名都变成大写模式，就可以这样写：</p>\n<p>fun main() {<br>    val list = listOf(“Apple”, “Banana”, “Orange”, “Pear”, “Grape”, “Watermelon”)<br>    val newList = list.map({ fruit: String -&gt; fruit.toUpperCase() })<br>    for (fruit in newList) {<br>        println(fruit)<br>    }<br>}</p>\n<ul>\n<li><p>当Lambda参数是函数的最后一个参数时，可以将Lambda表达式移到函数括号的外面。</p>\n</li>\n<li><p>如果Lambda参数是函数的唯一一个参数的话，还可以将函数的括号省略。</p>\n</li>\n<li><p>由于Kotlin拥有出色的类型推导机制，Lambda表达式中的参数列表其实在大多数情况下也<code>不必声明参数类型</code>。</p>\n</li>\n<li><p>当Lambda表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用<code>it</code>关键字来代替。</p>\n</li>\n</ul>\n<p>因此，Lambda表达式的写法可以进一步简化成如下方式：</p>\n<p>val newList = list.map { it.toUpperCase() }</p>\n<h3 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h3><p>Kotlin中引入了一个可空类型系统的概念，它利用编译时判空检查的机制几乎杜绝了空指针异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun doStudy(study: Study) &#123;</span><br><span class=\"line\">    study.readBooks()</span><br><span class=\"line\">    study.doHomework()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码实际上它是没有空指针风险的，因为Kotlin默认所有的参数和变量都不可为空，所以这里传入的Study参数也一定不会为空，可以放心地调用它的任何函数。</p>\n<p>Kotlin提供了另外一套可为空的类型系统，就是在类名的后面加上一个问号。比如，Int表示不可为空的整型，而Int?就表示可为空的整型；String表示不可为空的字符串，而String?就表示可为空的字符串。</p>\n<p>使用可为空的类型系统时，需要在编译时期就把所有的空指针异常都处理掉才行。</p>\n<p>Kotlin提供了一系列的辅助工具，使开发者能够更轻松地进行判空处理。</p>\n<p>?. 操作符表示当对象不为空时正常调用相应的方法，当对象为空时则什么都不做。比如：</p>\n<p>if (a != null) {<br>    a.doSomething()<br>}</p>\n<p>这段代码使用?.操作符就可以简化成：</p>\n<p>a?.doSomething()</p>\n<p>?: 操作符表示如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。比如：</p>\n<p>val c = if (a ! = null) {<br>    a<br>} else {<br>    b<br>}</p>\n<p>这段代码的逻辑使用?:操作符就可以简化成：</p>\n<p>val c = a ?: b</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>Kotlin中字符串内嵌表达式的语法规则如下：</p>\n<p>“hello, ${obj.name}. nice to meet you!”</p>\n<p>当表达式中仅有一个变量的时候，还可以将两边的大括号省略：</p>\n<p>“hello, $name. nice to meet you!”</p>\n<h3 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun printParams(num: Int, str: String = &quot;hello&quot;) &#123;</span><br><span class=\"line\">    println(&quot;num is $num , str is $str&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Linux C 连接Mysql","date":"2021-11-02T07:56:45.912Z","_content":" \n\n## 依赖 和 软件\n\n\n","source":"_posts/Linux c 连接mysql.md","raw":"---\ntitle: Linux c 连接mysql\ndate: 2020-01-304 15:58:02\ncategories:\n- c/c++\ntags:\n- mysql\n- linux\n--- \n\n## 依赖 和 软件\n\n\n","slug":"Linux c 连接mysql","published":1,"updated":"2021-11-02T07:56:45.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gbli0006zsw70yya7fib","content":"<h2 id=\"依赖-和-软件\"><a href=\"#依赖-和-软件\" class=\"headerlink\" title=\"依赖 和 软件\"></a>依赖 和 软件</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"依赖-和-软件\"><a href=\"#依赖-和-软件\" class=\"headerlink\" title=\"依赖 和 软件\"></a>依赖 和 软件</h2>"},{"title":"Linux权限","date":"2021-11-03T03:05:09.000Z","_content":"\n# 用户\n\n## 1.添加用户\n\n```text\nuseradd [options] [name]\n\noptions:\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\n```\n```bash\nuseradd -d /home/admin -m admin\n```\n\n## 2.删除用户\n```text\nuserdel [options] [name]\n\noptions:\n-r 删除同时删除用户主目录\n\n```\n```bash\nuserdel -r admin\n```\n\n## 3.修改用户\n```text\nusermod [options] [name]\n\noptions: 和useradd 一样\n```\n```bash\nuserdel -r admin\n```\n\n### 4.用户密码\n\n```text\npasswd [options] [name]\n\noptions:\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。\n\n\n```\n普通用户密码修改\n```bash\npasswd\n```\n超级用户，可以指定任何用户的口令\n```bash\npasswd admin \n```\n\n# 组\n\n### 1.添加用户组\n\n```text\ngroupadd [options] [name]\n\noptions:\n-g GID 指定新用户组的组标识号（GID）。\n-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n```\n添加admin 组\n```bash\ngroupadd admin\n```\n\n### 2.删除组\n```bash\ngroupdel  admin \n```\n\n### 3.修改组\n```bash\ngroupmod -g 10000 -n  admin admin1 \n```\n\n```text\n-g GID 为用户组指定新的组标识号。\n-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n-n新用户组 将用户组的名字改为新名字\n```","source":"_posts/Linux权限.md","raw":"---\ntitle: Linux权限\ncategories:\n  - 操作系统\ntags:\n  - linux\ndate: 2021-11-03 11:05:09\n---\n\n# 用户\n\n## 1.添加用户\n\n```text\nuseradd [options] [name]\n\noptions:\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\n```\n```bash\nuseradd -d /home/admin -m admin\n```\n\n## 2.删除用户\n```text\nuserdel [options] [name]\n\noptions:\n-r 删除同时删除用户主目录\n\n```\n```bash\nuserdel -r admin\n```\n\n## 3.修改用户\n```text\nusermod [options] [name]\n\noptions: 和useradd 一样\n```\n```bash\nuserdel -r admin\n```\n\n### 4.用户密码\n\n```text\npasswd [options] [name]\n\noptions:\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。\n\n\n```\n普通用户密码修改\n```bash\npasswd\n```\n超级用户，可以指定任何用户的口令\n```bash\npasswd admin \n```\n\n# 组\n\n### 1.添加用户组\n\n```text\ngroupadd [options] [name]\n\noptions:\n-g GID 指定新用户组的组标识号（GID）。\n-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n```\n添加admin 组\n```bash\ngroupadd admin\n```\n\n### 2.删除组\n```bash\ngroupdel  admin \n```\n\n### 3.修改组\n```bash\ngroupmod -g 10000 -n  admin admin1 \n```\n\n```text\n-g GID 为用户组指定新的组标识号。\n-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n-n新用户组 将用户组的名字改为新名字\n```","slug":"Linux权限","published":1,"updated":"2021-11-03T03:28:28.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblk0009zsw7fty4didj","content":"<h1 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h1><h2 id=\"1-添加用户\"><a href=\"#1-添加用户\" class=\"headerlink\" title=\"1.添加用户\"></a>1.添加用户</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-c comment 指定一段注释性描述。</span><br><span class=\"line\">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class=\"line\">-g 用户组 指定用户所属的用户组。</span><br><span class=\"line\">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class=\"line\">-s Shell文件 指定用户的登录Shell。</span><br><span class=\"line\">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd -d /home/admin -m admin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-删除用户\"><a href=\"#2-删除用户\" class=\"headerlink\" title=\"2.删除用户\"></a>2.删除用户</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-r 删除同时删除用户主目录</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel -r admin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-修改用户\"><a href=\"#3-修改用户\" class=\"headerlink\" title=\"3.修改用户\"></a>3.修改用户</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usermod [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options: 和useradd 一样</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel -r admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-用户密码\"><a href=\"#4-用户密码\" class=\"headerlink\" title=\"4.用户密码\"></a>4.用户密码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-l 锁定口令，即禁用账号。</span><br><span class=\"line\">-u 口令解锁。</span><br><span class=\"line\">-d 使账号无口令。</span><br><span class=\"line\">-f 强迫用户下次登录时修改口令。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>普通用户密码修改</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd</span><br></pre></td></tr></table></figure>\n<p>超级用户，可以指定任何用户的口令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd admin </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"组\"><a href=\"#组\" class=\"headerlink\" title=\"组\"></a>组</h1><h3 id=\"1-添加用户组\"><a href=\"#1-添加用户组\" class=\"headerlink\" title=\"1.添加用户组\"></a>1.添加用户组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-g GID 指定新用户组的组标识号（GID）。</span><br><span class=\"line\">-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>添加admin 组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-删除组\"><a href=\"#2-删除组\" class=\"headerlink\" title=\"2.删除组\"></a>2.删除组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupdel  admin </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-修改组\"><a href=\"#3-修改组\" class=\"headerlink\" title=\"3.修改组\"></a>3.修改组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupmod -g 10000 -n  admin admin1 </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-g GID 为用户组指定新的组标识号。</span><br><span class=\"line\">-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</span><br><span class=\"line\">-n新用户组 将用户组的名字改为新名字</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h1><h2 id=\"1-添加用户\"><a href=\"#1-添加用户\" class=\"headerlink\" title=\"1.添加用户\"></a>1.添加用户</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-c comment 指定一段注释性描述。</span><br><span class=\"line\">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class=\"line\">-g 用户组 指定用户所属的用户组。</span><br><span class=\"line\">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class=\"line\">-s Shell文件 指定用户的登录Shell。</span><br><span class=\"line\">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd -d /home/admin -m admin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-删除用户\"><a href=\"#2-删除用户\" class=\"headerlink\" title=\"2.删除用户\"></a>2.删除用户</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-r 删除同时删除用户主目录</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel -r admin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-修改用户\"><a href=\"#3-修改用户\" class=\"headerlink\" title=\"3.修改用户\"></a>3.修改用户</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usermod [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options: 和useradd 一样</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userdel -r admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-用户密码\"><a href=\"#4-用户密码\" class=\"headerlink\" title=\"4.用户密码\"></a>4.用户密码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-l 锁定口令，即禁用账号。</span><br><span class=\"line\">-u 口令解锁。</span><br><span class=\"line\">-d 使账号无口令。</span><br><span class=\"line\">-f 强迫用户下次登录时修改口令。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>普通用户密码修改</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd</span><br></pre></td></tr></table></figure>\n<p>超级用户，可以指定任何用户的口令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd admin </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"组\"><a href=\"#组\" class=\"headerlink\" title=\"组\"></a>组</h1><h3 id=\"1-添加用户组\"><a href=\"#1-添加用户组\" class=\"headerlink\" title=\"1.添加用户组\"></a>1.添加用户组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd [options] [name]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-g GID 指定新用户组的组标识号（GID）。</span><br><span class=\"line\">-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>添加admin 组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-删除组\"><a href=\"#2-删除组\" class=\"headerlink\" title=\"2.删除组\"></a>2.删除组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupdel  admin </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-修改组\"><a href=\"#3-修改组\" class=\"headerlink\" title=\"3.修改组\"></a>3.修改组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupmod -g 10000 -n  admin admin1 </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-g GID 为用户组指定新的组标识号。</span><br><span class=\"line\">-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</span><br><span class=\"line\">-n新用户组 将用户组的名字改为新名字</span><br></pre></td></tr></table></figure>"},{"title":"Mongo笔记","date":"2020-09-29T09:01:43.000Z","_content":"## 数据备份\nmongodump /h 10.1.56.74 /port 27017   /d JHQDB /o ./\n\n## 数据恢复\n mongorestore.exe -h localhost:27017 -d JHQDB d:\\mongo\\localdate\\JHQDB \n\n##数据导出\nmongoexport /h 10.11.36.66 /port 27017 /d VISITORDB /o register_record.json /c register_record\n\n\n## 数据库\nuse test\ndb\nshow dbs\ndb.dropDatabases()\ndb.colllection.drop()\n## curd\ndb.user.insert(\"name\":\"a\",\"age\":\"23\")\ndb.user.find()\n可以将数据定义为变量\nuserb=({\"name\":\"b\",\"age\":\"34\"});\ndb.user.insert(userb)\n删除\ndb.user.remove({\"name\":\"a\"})\n删除所有\ndb.user.remove({})\n格式化显示\ndb.user.find().pretty()、\n\n\n\n## 聚合\n\nmongodb 中聚合（aggregate）主要用于处理数据（诸如统计平均值求和等），并返回计算后的处理结果。\n\n\n\n### 语法\n\ndb.collection.aggregate(aggregate_options)\n\n\n\n| 表达式 | 描述     | 实例                                            |\n| ------ | -------- | ----------------------------------------------- |\n| $sum   | 计算总和 | db.mycol.aggregate([{$group:{_id:\"$by_user\"}}]) |\n\n\n\n## 练习\n\n### 数据\n\n```js\ndb.user.insert({\"name\":\"qlq1\",\"age\":20,\"sex\":\"男\"})\n\ndb.user.insert({\"name\":\"qlq2\",\"age\":22,\"sex\" :\"男\"})\n\ndb.user.insert({\"name\":\"qlq3\",\"age\":23,\"sex\":\"女\"})\n\ndb.user.insert({\"name\":\"qlq4\",\"age\":24,\"sex\":\"女\"})\n```\n\n`使用方法：使用管道过滤数据之后利用表达式对数据进行操作：`\n\n- 测试分组与管道表达式:$group 分组统计\n\n  ##### 1. 按性别分组，并统计男女人数\n\n  ```javascript\n  db.user.aggregate([{$group:{_id:\"$sex\",num:{$sum:1}}}])\n  ```\n\n  解释:_id:\"$sex\"表示按sex属性分组，$sum表示求和，如果$sum:1就相当于count(*)，一行记录算一个\n\n  ##### 2. 按性别分组，计算年龄和\n\n  ```\n  db.user.aggregate([{$group:{_id:\"$sex\",num:{$sum:\"$age\"}}}])\n  ```\n\n  ##### 3. 按性别分组，并拿到每个组的第一个年龄\n\n  ```javascript\n  db.user.aggregate([{$group:{_id:\"$sex\",num:{$first:\"$age\"}}}])\n  ```\n\n  ##### 4. 先按性别分组，分完组之后将age属性映射到数组中\n\n  ```\n  db.user.aggregate({$group:{_id:\"$sex\",num:{$push:\"$age\"}}})\n  ```\n\n  `如果是将所有列都添加到数组中用 $push:$$ROOT`\n\n  ```\n  db.user.aggregate([{$group:{_id:\"$sex\",num:{$push:\"$$ROOT\"}}}])-\n  ```\n\n  - $match :类似于find，只是find不能统计，现在可以过滤并统计\n\n  ##### 1. 查询年龄大于23小于等于50的\n\n    ```\ndb.user.aggregate([{$match:{age:{$gt:23,$lt:50}}}])\n    ```\n  \n  \n  \n  ","source":"_posts/mongo.md","raw":"---\ntitle: mongo笔记\ndate: 2020-09-29 17:01:43\ncategories: 数据库\ntags: mongo\n---\n## 数据备份\nmongodump /h 10.1.56.74 /port 27017   /d JHQDB /o ./\n\n## 数据恢复\n mongorestore.exe -h localhost:27017 -d JHQDB d:\\mongo\\localdate\\JHQDB \n\n##数据导出\nmongoexport /h 10.11.36.66 /port 27017 /d VISITORDB /o register_record.json /c register_record\n\n\n## 数据库\nuse test\ndb\nshow dbs\ndb.dropDatabases()\ndb.colllection.drop()\n## curd\ndb.user.insert(\"name\":\"a\",\"age\":\"23\")\ndb.user.find()\n可以将数据定义为变量\nuserb=({\"name\":\"b\",\"age\":\"34\"});\ndb.user.insert(userb)\n删除\ndb.user.remove({\"name\":\"a\"})\n删除所有\ndb.user.remove({})\n格式化显示\ndb.user.find().pretty()、\n\n\n\n## 聚合\n\nmongodb 中聚合（aggregate）主要用于处理数据（诸如统计平均值求和等），并返回计算后的处理结果。\n\n\n\n### 语法\n\ndb.collection.aggregate(aggregate_options)\n\n\n\n| 表达式 | 描述     | 实例                                            |\n| ------ | -------- | ----------------------------------------------- |\n| $sum   | 计算总和 | db.mycol.aggregate([{$group:{_id:\"$by_user\"}}]) |\n\n\n\n## 练习\n\n### 数据\n\n```js\ndb.user.insert({\"name\":\"qlq1\",\"age\":20,\"sex\":\"男\"})\n\ndb.user.insert({\"name\":\"qlq2\",\"age\":22,\"sex\" :\"男\"})\n\ndb.user.insert({\"name\":\"qlq3\",\"age\":23,\"sex\":\"女\"})\n\ndb.user.insert({\"name\":\"qlq4\",\"age\":24,\"sex\":\"女\"})\n```\n\n`使用方法：使用管道过滤数据之后利用表达式对数据进行操作：`\n\n- 测试分组与管道表达式:$group 分组统计\n\n  ##### 1. 按性别分组，并统计男女人数\n\n  ```javascript\n  db.user.aggregate([{$group:{_id:\"$sex\",num:{$sum:1}}}])\n  ```\n\n  解释:_id:\"$sex\"表示按sex属性分组，$sum表示求和，如果$sum:1就相当于count(*)，一行记录算一个\n\n  ##### 2. 按性别分组，计算年龄和\n\n  ```\n  db.user.aggregate([{$group:{_id:\"$sex\",num:{$sum:\"$age\"}}}])\n  ```\n\n  ##### 3. 按性别分组，并拿到每个组的第一个年龄\n\n  ```javascript\n  db.user.aggregate([{$group:{_id:\"$sex\",num:{$first:\"$age\"}}}])\n  ```\n\n  ##### 4. 先按性别分组，分完组之后将age属性映射到数组中\n\n  ```\n  db.user.aggregate({$group:{_id:\"$sex\",num:{$push:\"$age\"}}})\n  ```\n\n  `如果是将所有列都添加到数组中用 $push:$$ROOT`\n\n  ```\n  db.user.aggregate([{$group:{_id:\"$sex\",num:{$push:\"$$ROOT\"}}}])-\n  ```\n\n  - $match :类似于find，只是find不能统计，现在可以过滤并统计\n\n  ##### 1. 查询年龄大于23小于等于50的\n\n    ```\ndb.user.aggregate([{$match:{age:{$gt:23,$lt:50}}}])\n    ```\n  \n  \n  \n  ","slug":"mongo","published":1,"updated":"2021-11-02T07:56:45.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblm000azsw749cwafj4","content":"<h2 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h2><p>mongodump /h 10.1.56.74 /port 27017   /d JHQDB /o ./</p>\n<h2 id=\"数据恢复\"><a href=\"#数据恢复\" class=\"headerlink\" title=\"数据恢复\"></a>数据恢复</h2><p> mongorestore.exe -h localhost:27017 -d JHQDB d:\\mongo\\localdate\\JHQDB </p>\n<p>##数据导出<br>mongoexport /h 10.11.36.66 /port 27017 /d VISITORDB /o register_record.json /c register_record</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><p>use test<br>db<br>show dbs<br>db.dropDatabases()<br>db.colllection.drop()</p>\n<h2 id=\"curd\"><a href=\"#curd\" class=\"headerlink\" title=\"curd\"></a>curd</h2><p>db.user.insert(“name”:”a”,”age”:”23”)<br>db.user.find()<br>可以将数据定义为变量<br>userb=({“name”:”b”,”age”:”34”});<br>db.user.insert(userb)<br>删除<br>db.user.remove({“name”:”a”})<br>删除所有<br>db.user.remove({})<br>格式化显示<br>db.user.find().pretty()、</p>\n<h2 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h2><p>mongodb 中聚合（aggregate）主要用于处理数据（诸如统计平均值求和等），并返回计算后的处理结果。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>db.collection.aggregate(aggregate_options)</p>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$sum</td>\n<td>计算总和</td>\n<td>db.mycol.aggregate([{$group:{_id:”$by_user”}}])</td>\n</tr>\n</tbody></table>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;qlq1&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">20</span>,<span class=\"string\">&quot;sex&quot;</span>:<span class=\"string\">&quot;男&quot;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;qlq2&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">22</span>,<span class=\"string\">&quot;sex&quot;</span> :<span class=\"string\">&quot;男&quot;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;qlq3&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">23</span>,<span class=\"string\">&quot;sex&quot;</span>:<span class=\"string\">&quot;女&quot;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;qlq4&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">24</span>,<span class=\"string\">&quot;sex&quot;</span>:<span class=\"string\">&quot;女&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>使用方法：使用管道过滤数据之后利用表达式对数据进行操作：</code></p>\n<ul>\n<li><p>测试分组与管道表达式:$group 分组统计</p>\n<h5 id=\"1-按性别分组，并统计男女人数\"><a href=\"#1-按性别分组，并统计男女人数\" class=\"headerlink\" title=\"1. 按性别分组，并统计男女人数\"></a>1. 按性别分组，并统计男女人数</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;<span class=\"attr\">$group</span>:&#123;<span class=\"attr\">_id</span>:<span class=\"string\">&quot;$sex&quot;</span>,<span class=\"attr\">num</span>:&#123;<span class=\"attr\">$sum</span>:<span class=\"number\">1</span>&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>\n\n<p>解释:_id:”$sex”表示按sex属性分组，$sum表示求和，如果$sum:1就相当于count(*)，一行记录算一个</p>\n<h5 id=\"2-按性别分组，计算年龄和\"><a href=\"#2-按性别分组，计算年龄和\" class=\"headerlink\" title=\"2. 按性别分组，计算年龄和\"></a>2. 按性别分组，计算年龄和</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;$group:&#123;_id:&quot;$sex&quot;,num:&#123;$sum:&quot;$age&quot;&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-按性别分组，并拿到每个组的第一个年龄\"><a href=\"#3-按性别分组，并拿到每个组的第一个年龄\" class=\"headerlink\" title=\"3. 按性别分组，并拿到每个组的第一个年龄\"></a>3. 按性别分组，并拿到每个组的第一个年龄</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;<span class=\"attr\">$group</span>:&#123;<span class=\"attr\">_id</span>:<span class=\"string\">&quot;$sex&quot;</span>,<span class=\"attr\">num</span>:&#123;<span class=\"attr\">$first</span>:<span class=\"string\">&quot;$age&quot;</span>&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-先按性别分组，分完组之后将age属性映射到数组中\"><a href=\"#4-先按性别分组，分完组之后将age属性映射到数组中\" class=\"headerlink\" title=\"4. 先按性别分组，分完组之后将age属性映射到数组中\"></a>4. 先按性别分组，分完组之后将age属性映射到数组中</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate(&#123;$group:&#123;_id:&quot;$sex&quot;,num:&#123;$push:&quot;$age&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>如果是将所有列都添加到数组中用 $push:$$ROOT</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;$group:&#123;_id:&quot;$sex&quot;,num:&#123;$push:&quot;$$ROOT&quot;&#125;&#125;&#125;])-</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>$match :类似于find，只是find不能统计，现在可以过滤并统计</li>\n</ul>\n<h5 id=\"1-查询年龄大于23小于等于50的\"><a href=\"#1-查询年龄大于23小于等于50的\" class=\"headerlink\" title=\"1. 查询年龄大于23小于等于50的\"></a>1. 查询年龄大于23小于等于50的</h5>  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;$match:&#123;age:&#123;$gt:23,$lt:50&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h2><p>mongodump /h 10.1.56.74 /port 27017   /d JHQDB /o ./</p>\n<h2 id=\"数据恢复\"><a href=\"#数据恢复\" class=\"headerlink\" title=\"数据恢复\"></a>数据恢复</h2><p> mongorestore.exe -h localhost:27017 -d JHQDB d:\\mongo\\localdate\\JHQDB </p>\n<p>##数据导出<br>mongoexport /h 10.11.36.66 /port 27017 /d VISITORDB /o register_record.json /c register_record</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><p>use test<br>db<br>show dbs<br>db.dropDatabases()<br>db.colllection.drop()</p>\n<h2 id=\"curd\"><a href=\"#curd\" class=\"headerlink\" title=\"curd\"></a>curd</h2><p>db.user.insert(“name”:”a”,”age”:”23”)<br>db.user.find()<br>可以将数据定义为变量<br>userb=({“name”:”b”,”age”:”34”});<br>db.user.insert(userb)<br>删除<br>db.user.remove({“name”:”a”})<br>删除所有<br>db.user.remove({})<br>格式化显示<br>db.user.find().pretty()、</p>\n<h2 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h2><p>mongodb 中聚合（aggregate）主要用于处理数据（诸如统计平均值求和等），并返回计算后的处理结果。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>db.collection.aggregate(aggregate_options)</p>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$sum</td>\n<td>计算总和</td>\n<td>db.mycol.aggregate([{$group:{_id:”$by_user”}}])</td>\n</tr>\n</tbody></table>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;qlq1&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">20</span>,<span class=\"string\">&quot;sex&quot;</span>:<span class=\"string\">&quot;男&quot;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;qlq2&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">22</span>,<span class=\"string\">&quot;sex&quot;</span> :<span class=\"string\">&quot;男&quot;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;qlq3&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">23</span>,<span class=\"string\">&quot;sex&quot;</span>:<span class=\"string\">&quot;女&quot;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;qlq4&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">24</span>,<span class=\"string\">&quot;sex&quot;</span>:<span class=\"string\">&quot;女&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>使用方法：使用管道过滤数据之后利用表达式对数据进行操作：</code></p>\n<ul>\n<li><p>测试分组与管道表达式:$group 分组统计</p>\n<h5 id=\"1-按性别分组，并统计男女人数\"><a href=\"#1-按性别分组，并统计男女人数\" class=\"headerlink\" title=\"1. 按性别分组，并统计男女人数\"></a>1. 按性别分组，并统计男女人数</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;<span class=\"attr\">$group</span>:&#123;<span class=\"attr\">_id</span>:<span class=\"string\">&quot;$sex&quot;</span>,<span class=\"attr\">num</span>:&#123;<span class=\"attr\">$sum</span>:<span class=\"number\">1</span>&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>\n\n<p>解释:_id:”$sex”表示按sex属性分组，$sum表示求和，如果$sum:1就相当于count(*)，一行记录算一个</p>\n<h5 id=\"2-按性别分组，计算年龄和\"><a href=\"#2-按性别分组，计算年龄和\" class=\"headerlink\" title=\"2. 按性别分组，计算年龄和\"></a>2. 按性别分组，计算年龄和</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;$group:&#123;_id:&quot;$sex&quot;,num:&#123;$sum:&quot;$age&quot;&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-按性别分组，并拿到每个组的第一个年龄\"><a href=\"#3-按性别分组，并拿到每个组的第一个年龄\" class=\"headerlink\" title=\"3. 按性别分组，并拿到每个组的第一个年龄\"></a>3. 按性别分组，并拿到每个组的第一个年龄</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;<span class=\"attr\">$group</span>:&#123;<span class=\"attr\">_id</span>:<span class=\"string\">&quot;$sex&quot;</span>,<span class=\"attr\">num</span>:&#123;<span class=\"attr\">$first</span>:<span class=\"string\">&quot;$age&quot;</span>&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-先按性别分组，分完组之后将age属性映射到数组中\"><a href=\"#4-先按性别分组，分完组之后将age属性映射到数组中\" class=\"headerlink\" title=\"4. 先按性别分组，分完组之后将age属性映射到数组中\"></a>4. 先按性别分组，分完组之后将age属性映射到数组中</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate(&#123;$group:&#123;_id:&quot;$sex&quot;,num:&#123;$push:&quot;$age&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>如果是将所有列都添加到数组中用 $push:$$ROOT</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;$group:&#123;_id:&quot;$sex&quot;,num:&#123;$push:&quot;$$ROOT&quot;&#125;&#125;&#125;])-</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>$match :类似于find，只是find不能统计，现在可以过滤并统计</li>\n</ul>\n<h5 id=\"1-查询年龄大于23小于等于50的\"><a href=\"#1-查询年龄大于23小于等于50的\" class=\"headerlink\" title=\"1. 查询年龄大于23小于等于50的\"></a>1. 查询年龄大于23小于等于50的</h5>  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.aggregate([&#123;$match:&#123;age:&#123;$gt:23,$lt:50&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n"},{"title":"Docker基本概念","date":"2020-12-10T09:19:02.000Z","_content":"\n## 位逻辑运算符\n\n&（与）、|（或）、~（非）和 ^（异或）。除了 ~（即位取反）为单目运算符外，其余都为双目运算符\n\n| 运算符  | 含义\t              | 实例\t     | 结果  |\n| ----   | ----               | ----     | ---- |\n| &      |按位进行与运算(AND)    |\t4 & 5    |\t4   |\n| &#124; |按位进行或运算(OR)     |\t4 | 5\t |5     |\n|^       |按位进行异或运算(XOR)  |\t4 ^ 5    |\t1   |\n|~\t     |按位进行取反运算(NOT)  |\t~ 4\t-5   |      |\n\n\n异或运算有以下三个性质。\n\n1、任何数和 0 做异或运算，结果仍然是原来的数，即 a ⊕ 0= a。\n2、任何数和其自身做异或运算，结果是 0，即 a ⊕ a=a。\n3、异或运算满足交换律和结合律，即 a ⊕ b ⊕ a=b ⊕ a ⊕ a=b ⊕ (a ⊕ a)=b ⊕0=ba⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。\n\n\n\n","source":"_posts/位运算.md","raw":"---\ntitle: Docker基本概念\ndate: 2020-12-10 17:19:02\ncategories: 算法\ntags: \n- java\n---\n\n## 位逻辑运算符\n\n&（与）、|（或）、~（非）和 ^（异或）。除了 ~（即位取反）为单目运算符外，其余都为双目运算符\n\n| 运算符  | 含义\t              | 实例\t     | 结果  |\n| ----   | ----               | ----     | ---- |\n| &      |按位进行与运算(AND)    |\t4 & 5    |\t4   |\n| &#124; |按位进行或运算(OR)     |\t4 | 5\t |5     |\n|^       |按位进行异或运算(XOR)  |\t4 ^ 5    |\t1   |\n|~\t     |按位进行取反运算(NOT)  |\t~ 4\t-5   |      |\n\n\n异或运算有以下三个性质。\n\n1、任何数和 0 做异或运算，结果仍然是原来的数，即 a ⊕ 0= a。\n2、任何数和其自身做异或运算，结果是 0，即 a ⊕ a=a。\n3、异或运算满足交换律和结合律，即 a ⊕ b ⊕ a=b ⊕ a ⊕ a=b ⊕ (a ⊕ a)=b ⊕0=ba⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。\n\n\n\n","slug":"位运算","published":1,"updated":"2021-11-03T02:24:12.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblo000fzsw7hmmo4o86","content":"<h2 id=\"位逻辑运算符\"><a href=\"#位逻辑运算符\" class=\"headerlink\" title=\"位逻辑运算符\"></a>位逻辑运算符</h2><p>&amp;（与）、|（或）、~（非）和 ^（异或）。除了 ~（即位取反）为单目运算符外，其余都为双目运算符</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>含义</th>\n<th>实例</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>按位进行与运算(AND)</td>\n<td>4 &amp; 5</td>\n<td>4</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>按位进行或运算(OR)</td>\n<td>4</td>\n<td>5</td>\n</tr>\n<tr>\n<td>^</td>\n<td>按位进行异或运算(XOR)</td>\n<td>4 ^ 5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>~</td>\n<td>按位进行取反运算(NOT)</td>\n<td>~ 4    -5</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>异或运算有以下三个性质。</p>\n<p>1、任何数和 0 做异或运算，结果仍然是原来的数，即 a ⊕ 0= a。<br>2、任何数和其自身做异或运算，结果是 0，即 a ⊕ a=a。<br>3、异或运算满足交换律和结合律，即 a ⊕ b ⊕ a=b ⊕ a ⊕ a=b ⊕ (a ⊕ a)=b ⊕0=ba⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"位逻辑运算符\"><a href=\"#位逻辑运算符\" class=\"headerlink\" title=\"位逻辑运算符\"></a>位逻辑运算符</h2><p>&amp;（与）、|（或）、~（非）和 ^（异或）。除了 ~（即位取反）为单目运算符外，其余都为双目运算符</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>含义</th>\n<th>实例</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>按位进行与运算(AND)</td>\n<td>4 &amp; 5</td>\n<td>4</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>按位进行或运算(OR)</td>\n<td>4</td>\n<td>5</td>\n</tr>\n<tr>\n<td>^</td>\n<td>按位进行异或运算(XOR)</td>\n<td>4 ^ 5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>~</td>\n<td>按位进行取反运算(NOT)</td>\n<td>~ 4    -5</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>异或运算有以下三个性质。</p>\n<p>1、任何数和 0 做异或运算，结果仍然是原来的数，即 a ⊕ 0= a。<br>2、任何数和其自身做异或运算，结果是 0，即 a ⊕ a=a。<br>3、异或运算满足交换律和结合律，即 a ⊕ b ⊕ a=b ⊕ a ⊕ a=b ⊕ (a ⊕ a)=b ⊕0=ba⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</p>\n"},{"title":"安卓基础知识","date":"2020-09-30T07:52:05.000Z","_content":"\n## 应用组件\n\n应用组件是安卓应用的基本构建块。每个组件都是一个基本入口点，系统或用户可以通过该入口点进入您的应用。有些组件会依赖于其他组件。\n四种不同的应用组件类型：\n- Activity\n- 服务\n- 广播接收器\n- 内容提供程序\n\n### Activity\n\n一种可以包含用户界面的组件，用于和用户进行交互。\n\n声明 Activity，manifests，并添加 <activity> 元素作为 <application> 元素的子元素\n```\n    <manifest ... >\n      <application ... >\n          <activity android:name=\".ExampleActivity\" />\n          ...\n      </application ... >\n      ...\n    </manifest >\n```\n\n所有的Activity都要在AndroidManifest.xml中进行注册才能生效。Activity的注册声明要放在<application>标签内，并通过<activity>标签来对Activity进行注册。\n\n还可以通过在<activity>标签的内部加入<intent-filter>标签来配置主Activity。\n\n```\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n          package=\"com.example.activitytest\">\n\n    <application …>\n        <activity android:name=\".FirstActivity\" android:label=\"This is FirstActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n\n```\n  \n#### 声明 intent 过滤器\n\n借助intent，可以根据显式请求启动 Activity，还可以隐式请求启动 Activity。\n使用此功能，您需要在 <activity> 元素中声明 <intent-filter> 属性。此元素的定义包括 <action> 元素，以及可选的 <category> 元素和/或 <data> \n元素。这些元素组合在一起，可以指定 Activity 能够响应的 intent 类型。\n\n```\n    <activity android:name=\".ExampleActivity\" android:icon=\"@drawable/app_icon\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.SEND\" />\n            <category android:name=\"android.intent.category.DEFAULT\" />\n            <data android:mimeType=\"text/plain\" />\n        </intent-filter>\n    </activity>\n\n<action> 元素指定该 Activity 会发送数据。将 <category> 元素声明为 DEFAULT 可使 Activity 能够接收启动请求。<data> 元素指定此 Activity \n可以发送的数据类型。\n```\n","source":"_posts/安卓基础知识.md","raw":"---\ntitle: 安卓基础知识\ndate: 2020-09-30 15:52:05\ncategories: android\ntags: \n- android\n- kotlin\n---\n\n## 应用组件\n\n应用组件是安卓应用的基本构建块。每个组件都是一个基本入口点，系统或用户可以通过该入口点进入您的应用。有些组件会依赖于其他组件。\n四种不同的应用组件类型：\n- Activity\n- 服务\n- 广播接收器\n- 内容提供程序\n\n### Activity\n\n一种可以包含用户界面的组件，用于和用户进行交互。\n\n声明 Activity，manifests，并添加 <activity> 元素作为 <application> 元素的子元素\n```\n    <manifest ... >\n      <application ... >\n          <activity android:name=\".ExampleActivity\" />\n          ...\n      </application ... >\n      ...\n    </manifest >\n```\n\n所有的Activity都要在AndroidManifest.xml中进行注册才能生效。Activity的注册声明要放在<application>标签内，并通过<activity>标签来对Activity进行注册。\n\n还可以通过在<activity>标签的内部加入<intent-filter>标签来配置主Activity。\n\n```\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n          package=\"com.example.activitytest\">\n\n    <application …>\n        <activity android:name=\".FirstActivity\" android:label=\"This is FirstActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n\n```\n  \n#### 声明 intent 过滤器\n\n借助intent，可以根据显式请求启动 Activity，还可以隐式请求启动 Activity。\n使用此功能，您需要在 <activity> 元素中声明 <intent-filter> 属性。此元素的定义包括 <action> 元素，以及可选的 <category> 元素和/或 <data> \n元素。这些元素组合在一起，可以指定 Activity 能够响应的 intent 类型。\n\n```\n    <activity android:name=\".ExampleActivity\" android:icon=\"@drawable/app_icon\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.SEND\" />\n            <category android:name=\"android.intent.category.DEFAULT\" />\n            <data android:mimeType=\"text/plain\" />\n        </intent-filter>\n    </activity>\n\n<action> 元素指定该 Activity 会发送数据。将 <category> 元素声明为 DEFAULT 可使 Activity 能够接收启动请求。<data> 元素指定此 Activity \n可以发送的数据类型。\n```\n","slug":"安卓基础知识","published":1,"updated":"2021-11-02T07:56:45.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblq000izsw7axth35un","content":"<h2 id=\"应用组件\"><a href=\"#应用组件\" class=\"headerlink\" title=\"应用组件\"></a>应用组件</h2><p>应用组件是安卓应用的基本构建块。每个组件都是一个基本入口点，系统或用户可以通过该入口点进入您的应用。有些组件会依赖于其他组件。<br>四种不同的应用组件类型：</p>\n<ul>\n<li>Activity</li>\n<li>服务</li>\n<li>广播接收器</li>\n<li>内容提供程序</li>\n</ul>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>一种可以包含用户界面的组件，用于和用户进行交互。</p>\n<p>声明 Activity，manifests，并添加 <activity> 元素作为 <application> 元素的子元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest ... &gt;</span><br><span class=\"line\">  &lt;application ... &gt;</span><br><span class=\"line\">      &lt;activity android:name=&quot;.ExampleActivity&quot; /&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  &lt;/application ... &gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/manifest &gt;</span><br></pre></td></tr></table></figure>\n\n<p>所有的Activity都要在AndroidManifest.xml中进行注册才能生效。Activity的注册声明要放在<application>标签内，并通过<activity>标签来对Activity进行注册。</p>\n<p>还可以通过在<activity>标签的内部加入<intent-filter>标签来配置主Activity。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">          package=&quot;com.example.activitytest&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;application …&gt;</span><br><span class=\"line\">        &lt;activity android:name=&quot;.FirstActivity&quot; android:label=&quot;This is FirstActivity&quot;&gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\">        &lt;/activity&gt;</span><br><span class=\"line\">    &lt;/application&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/manifest&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"声明-intent-过滤器\"><a href=\"#声明-intent-过滤器\" class=\"headerlink\" title=\"声明 intent 过滤器\"></a>声明 intent 过滤器</h4><p>借助intent，可以根据显式请求启动 Activity，还可以隐式请求启动 Activity。<br>使用此功能，您需要在 <activity> 元素中声明 <intent-filter> 属性。此元素的定义包括 <action> 元素，以及可选的 <category> 元素和/或 <data><br>元素。这些元素组合在一起，可以指定 Activity 能够响应的 intent 类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;activity android:name=&quot;.ExampleActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt;</span><br><span class=\"line\">        &lt;intent-filter&gt;</span><br><span class=\"line\">            &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;</span><br><span class=\"line\">            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class=\"line\">            &lt;data android:mimeType=&quot;text/plain&quot; /&gt;</span><br><span class=\"line\">        &lt;/intent-filter&gt;</span><br><span class=\"line\">    &lt;/activity&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;action&gt; 元素指定该 Activity 会发送数据。将 &lt;category&gt; 元素声明为 DEFAULT 可使 Activity 能够接收启动请求。&lt;data&gt; 元素指定此 Activity </span><br><span class=\"line\">可以发送的数据类型。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用组件\"><a href=\"#应用组件\" class=\"headerlink\" title=\"应用组件\"></a>应用组件</h2><p>应用组件是安卓应用的基本构建块。每个组件都是一个基本入口点，系统或用户可以通过该入口点进入您的应用。有些组件会依赖于其他组件。<br>四种不同的应用组件类型：</p>\n<ul>\n<li>Activity</li>\n<li>服务</li>\n<li>广播接收器</li>\n<li>内容提供程序</li>\n</ul>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>一种可以包含用户界面的组件，用于和用户进行交互。</p>\n<p>声明 Activity，manifests，并添加 <activity> 元素作为 <application> 元素的子元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest ... &gt;</span><br><span class=\"line\">  &lt;application ... &gt;</span><br><span class=\"line\">      &lt;activity android:name=&quot;.ExampleActivity&quot; /&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  &lt;/application ... &gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/manifest &gt;</span><br></pre></td></tr></table></figure>\n\n<p>所有的Activity都要在AndroidManifest.xml中进行注册才能生效。Activity的注册声明要放在<application>标签内，并通过<activity>标签来对Activity进行注册。</p>\n<p>还可以通过在<activity>标签的内部加入<intent-filter>标签来配置主Activity。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">          package=&quot;com.example.activitytest&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;application …&gt;</span><br><span class=\"line\">        &lt;activity android:name=&quot;.FirstActivity&quot; android:label=&quot;This is FirstActivity&quot;&gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\">        &lt;/activity&gt;</span><br><span class=\"line\">    &lt;/application&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/manifest&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"声明-intent-过滤器\"><a href=\"#声明-intent-过滤器\" class=\"headerlink\" title=\"声明 intent 过滤器\"></a>声明 intent 过滤器</h4><p>借助intent，可以根据显式请求启动 Activity，还可以隐式请求启动 Activity。<br>使用此功能，您需要在 <activity> 元素中声明 <intent-filter> 属性。此元素的定义包括 <action> 元素，以及可选的 <category> 元素和/或 <data><br>元素。这些元素组合在一起，可以指定 Activity 能够响应的 intent 类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;activity android:name=&quot;.ExampleActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt;</span><br><span class=\"line\">        &lt;intent-filter&gt;</span><br><span class=\"line\">            &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;</span><br><span class=\"line\">            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class=\"line\">            &lt;data android:mimeType=&quot;text/plain&quot; /&gt;</span><br><span class=\"line\">        &lt;/intent-filter&gt;</span><br><span class=\"line\">    &lt;/activity&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;action&gt; 元素指定该 Activity 会发送数据。将 &lt;category&gt; 元素声明为 DEFAULT 可使 Activity 能够接收启动请求。&lt;data&gt; 元素指定此 Activity </span><br><span class=\"line\">可以发送的数据类型。</span><br></pre></td></tr></table></figure>\n"},{"title":"操作系统中 Heap 和 Stack 的区别","date":"2020-10-09T01:47:28.000Z","_content":"\n## 基本概念\n\n堆栈是两种数据结构，是一种数据项按序排列的数据结构，只能在一端进行插入删除操作。\n堆：队列优先，先进先出。\n栈：先进后出。\n\n## 区别（操作系统）\n\n1. 空间分配\n\n堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由os回收，分配方式；类似于链表。\n栈：由操作系统自动释放，存放函数的参数值、局部变量的值等，类似于数据结构中的栈。\n\n2. 缓存方式\n堆：二级缓存，生命周期由虚拟机的垃圾回收算法来决定。\n栈：一级缓存，被调用时处于存储空间中，调用完毕立即释放。\n\n3.数据结构\n堆：树\n栈：先进后出\n\n## 区别（Java）\n\n","source":"_posts/操作系统中-heap-和-stack-的区别.md","raw":"---\ntitle: 操作系统中 heap 和 stack 的区别\ndate: 2020-10-09 09:47:28\ncategories: 计算机基础\ntags: \n- 堆栈\n---\n\n## 基本概念\n\n堆栈是两种数据结构，是一种数据项按序排列的数据结构，只能在一端进行插入删除操作。\n堆：队列优先，先进先出。\n栈：先进后出。\n\n## 区别（操作系统）\n\n1. 空间分配\n\n堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由os回收，分配方式；类似于链表。\n栈：由操作系统自动释放，存放函数的参数值、局部变量的值等，类似于数据结构中的栈。\n\n2. 缓存方式\n堆：二级缓存，生命周期由虚拟机的垃圾回收算法来决定。\n栈：一级缓存，被调用时处于存储空间中，调用完毕立即释放。\n\n3.数据结构\n堆：树\n栈：先进后出\n\n## 区别（Java）\n\n","slug":"操作系统中-heap-和-stack-的区别","published":1,"updated":"2021-11-02T07:56:45.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gbls000nzsw72wumg07w","content":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>堆栈是两种数据结构，是一种数据项按序排列的数据结构，只能在一端进行插入删除操作。<br>堆：队列优先，先进先出。<br>栈：先进后出。</p>\n<h2 id=\"区别（操作系统）\"><a href=\"#区别（操作系统）\" class=\"headerlink\" title=\"区别（操作系统）\"></a>区别（操作系统）</h2><ol>\n<li>空间分配</li>\n</ol>\n<p>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由os回收，分配方式；类似于链表。<br>栈：由操作系统自动释放，存放函数的参数值、局部变量的值等，类似于数据结构中的栈。</p>\n<ol start=\"2\">\n<li>缓存方式<br>堆：二级缓存，生命周期由虚拟机的垃圾回收算法来决定。<br>栈：一级缓存，被调用时处于存储空间中，调用完毕立即释放。</li>\n</ol>\n<p>3.数据结构<br>堆：树<br>栈：先进后出</p>\n<h2 id=\"区别（Java）\"><a href=\"#区别（Java）\" class=\"headerlink\" title=\"区别（Java）\"></a>区别（Java）</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>堆栈是两种数据结构，是一种数据项按序排列的数据结构，只能在一端进行插入删除操作。<br>堆：队列优先，先进先出。<br>栈：先进后出。</p>\n<h2 id=\"区别（操作系统）\"><a href=\"#区别（操作系统）\" class=\"headerlink\" title=\"区别（操作系统）\"></a>区别（操作系统）</h2><ol>\n<li>空间分配</li>\n</ol>\n<p>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由os回收，分配方式；类似于链表。<br>栈：由操作系统自动释放，存放函数的参数值、局部变量的值等，类似于数据结构中的栈。</p>\n<ol start=\"2\">\n<li>缓存方式<br>堆：二级缓存，生命周期由虚拟机的垃圾回收算法来决定。<br>栈：一级缓存，被调用时处于存储空间中，调用完毕立即释放。</li>\n</ol>\n<p>3.数据结构<br>堆：树<br>栈：先进后出</p>\n<h2 id=\"区别（Java）\"><a href=\"#区别（Java）\" class=\"headerlink\" title=\"区别（Java）\"></a>区别（Java）</h2>"},{"title":"数据在内存中的存储(二进制形式存储)","date":"2020-12-30T07:58:02.000Z","_content":"\n## 二进制，是计算机处理数据的基础\n\n内存条是一个非常精密的部件，包含了上一个电子元器件，它们很小，达到了纳米级别。这些元器件实际上就是电路。电路的电压会变化，要么0V，要么5V。只有这\n两种电压。5V是通电，用1来表示，0V是断电，用0来表示。所以，一个元器件有两种状态，0和1.\n我们通过电路来控制这些元器件的通断电，会得到很多0,1的组合。例如8个元器件，有2^8=256种不同组合。给组合赋予定义，则构成了值。\n\n一般情况下我们不一个一个使用元器件，而是将8个元器件看做一个单位。1表示为0000001；\n\n一个元器件称为1个比特（bit）,8个元器件称为一字节（byte），以此类推。1024个字节为1kb；。。。","source":"_posts/数据在内存中的存储.md","raw":"---\ntitle: 数据在内存中的存储(二进制形式存储)\ndate: 2020-12-30 15:58:02\ncategories: 计算机基础\ntags: \n- c/c++\n---\n\n## 二进制，是计算机处理数据的基础\n\n内存条是一个非常精密的部件，包含了上一个电子元器件，它们很小，达到了纳米级别。这些元器件实际上就是电路。电路的电压会变化，要么0V，要么5V。只有这\n两种电压。5V是通电，用1来表示，0V是断电，用0来表示。所以，一个元器件有两种状态，0和1.\n我们通过电路来控制这些元器件的通断电，会得到很多0,1的组合。例如8个元器件，有2^8=256种不同组合。给组合赋予定义，则构成了值。\n\n一般情况下我们不一个一个使用元器件，而是将8个元器件看做一个单位。1表示为0000001；\n\n一个元器件称为1个比特（bit）,8个元器件称为一字节（byte），以此类推。1024个字节为1kb；。。。","slug":"数据在内存中的存储","published":1,"updated":"2021-11-02T07:56:45.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblt000pzsw78hro81my","content":"<h2 id=\"二进制，是计算机处理数据的基础\"><a href=\"#二进制，是计算机处理数据的基础\" class=\"headerlink\" title=\"二进制，是计算机处理数据的基础\"></a>二进制，是计算机处理数据的基础</h2><p>内存条是一个非常精密的部件，包含了上一个电子元器件，它们很小，达到了纳米级别。这些元器件实际上就是电路。电路的电压会变化，要么0V，要么5V。只有这<br>两种电压。5V是通电，用1来表示，0V是断电，用0来表示。所以，一个元器件有两种状态，0和1.<br>我们通过电路来控制这些元器件的通断电，会得到很多0,1的组合。例如8个元器件，有2^8=256种不同组合。给组合赋予定义，则构成了值。</p>\n<p>一般情况下我们不一个一个使用元器件，而是将8个元器件看做一个单位。1表示为0000001；</p>\n<p>一个元器件称为1个比特（bit）,8个元器件称为一字节（byte），以此类推。1024个字节为1kb；。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"二进制，是计算机处理数据的基础\"><a href=\"#二进制，是计算机处理数据的基础\" class=\"headerlink\" title=\"二进制，是计算机处理数据的基础\"></a>二进制，是计算机处理数据的基础</h2><p>内存条是一个非常精密的部件，包含了上一个电子元器件，它们很小，达到了纳米级别。这些元器件实际上就是电路。电路的电压会变化，要么0V，要么5V。只有这<br>两种电压。5V是通电，用1来表示，0V是断电，用0来表示。所以，一个元器件有两种状态，0和1.<br>我们通过电路来控制这些元器件的通断电，会得到很多0,1的组合。例如8个元器件，有2^8=256种不同组合。给组合赋予定义，则构成了值。</p>\n<p>一般情况下我们不一个一个使用元器件，而是将8个元器件看做一个单位。1表示为0000001；</p>\n<p>一个元器件称为1个比特（bit）,8个元器件称为一字节（byte），以此类推。1024个字节为1kb；。。。</p>\n"},{"title":"正则表达式","date":"2020-10-09T06:46:02.000Z","_content":"\n## 匹配模式\n\n- 横向膜或匹配\n\n    可匹配字符串长度不固定\n    使用量词{m,n}：表示连续出现至少m次，至多n次\n    例：/ab{2,5}c/:表示第一个字符是a，接下来是2~5个字符b，最后是字符c\n    ```javascript\n    //g 表示全局匹配\n    const regex=/ab{2,5}c/g;\n    const str=\"abc abbc abbbc abbbbc abbbbbc abbbbbbc\";\n    console.log(str.match(regex))\n    ```\n    // => [ 'abbc', 'abbbc', 'abbbbc', 'abbbbbc' ]\n    \n- 纵向模糊匹配\n    \n    一个匹配的字符串，具体到某一字符时，它可以不是某个确定的字符，可以有多种可能。\n    使用字符组[abc]:表示该字符可以是a、b、c中的任何一个\n    例：/a[123]b/: 可以匹配: 'a1b','a2b','a3b'\n    ```javascript\n    const regex=/a[123]c/g;\n    const str=\"a1c a2c a3c\";\n    console.log(str.match(regex))\n    ``` \n    // => [ 'a1c', 'a2c', 'a3c' ]\n\n## 字符组\n\n[abc]\n\n### 范围表示法\n\n    如果字符组里的字符特别多，可以使用范围表达式\n    ","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2020-10-09 14:46:02\ncategories: 计算机基础\ntags: \n- 正则\n---\n\n## 匹配模式\n\n- 横向膜或匹配\n\n    可匹配字符串长度不固定\n    使用量词{m,n}：表示连续出现至少m次，至多n次\n    例：/ab{2,5}c/:表示第一个字符是a，接下来是2~5个字符b，最后是字符c\n    ```javascript\n    //g 表示全局匹配\n    const regex=/ab{2,5}c/g;\n    const str=\"abc abbc abbbc abbbbc abbbbbc abbbbbbc\";\n    console.log(str.match(regex))\n    ```\n    // => [ 'abbc', 'abbbc', 'abbbbc', 'abbbbbc' ]\n    \n- 纵向模糊匹配\n    \n    一个匹配的字符串，具体到某一字符时，它可以不是某个确定的字符，可以有多种可能。\n    使用字符组[abc]:表示该字符可以是a、b、c中的任何一个\n    例：/a[123]b/: 可以匹配: 'a1b','a2b','a3b'\n    ```javascript\n    const regex=/a[123]c/g;\n    const str=\"a1c a2c a3c\";\n    console.log(str.match(regex))\n    ``` \n    // => [ 'a1c', 'a2c', 'a3c' ]\n\n## 字符组\n\n[abc]\n\n### 范围表示法\n\n    如果字符组里的字符特别多，可以使用范围表达式\n    ","slug":"正则表达式","published":1,"updated":"2021-11-02T07:56:45.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblw000tzsw75v99d9nv","content":"<h2 id=\"匹配模式\"><a href=\"#匹配模式\" class=\"headerlink\" title=\"匹配模式\"></a>匹配模式</h2><ul>\n<li><p>横向膜或匹配</p>\n<p>  可匹配字符串长度不固定<br>  使用量词{m,n}：表示连续出现至少m次，至多n次<br>  例：/ab{2,5}c/:表示第一个字符是a，接下来是2~5个字符b，最后是字符c</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//g 表示全局匹配</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> regex=<span class=\"regexp\">/ab&#123;2,5&#125;c/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str=<span class=\"string\">&quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(regex))</span><br></pre></td></tr></table></figure>\n<p>  // =&gt; [ ‘abbc’, ‘abbbc’, ‘abbbbc’, ‘abbbbbc’ ]</p>\n</li>\n<li><p>纵向模糊匹配</p>\n<p>  一个匹配的字符串，具体到某一字符时，它可以不是某个确定的字符，可以有多种可能。<br>  使用字符组[abc]:表示该字符可以是a、b、c中的任何一个<br>  例：/a[123]b/: 可以匹配: ‘a1b’,’a2b’,’a3b’</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> regex=<span class=\"regexp\">/a[123]c/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str=<span class=\"string\">&quot;a1c a2c a3c&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(regex))</span><br></pre></td></tr></table></figure>\n<p>  // =&gt; [ ‘a1c’, ‘a2c’, ‘a3c’ ]</p>\n</li>\n</ul>\n<h2 id=\"字符组\"><a href=\"#字符组\" class=\"headerlink\" title=\"字符组\"></a>字符组</h2><p>[abc]</p>\n<h3 id=\"范围表示法\"><a href=\"#范围表示法\" class=\"headerlink\" title=\"范围表示法\"></a>范围表示法</h3><pre><code>如果字符组里的字符特别多，可以使用范围表达式\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"匹配模式\"><a href=\"#匹配模式\" class=\"headerlink\" title=\"匹配模式\"></a>匹配模式</h2><ul>\n<li><p>横向膜或匹配</p>\n<p>  可匹配字符串长度不固定<br>  使用量词{m,n}：表示连续出现至少m次，至多n次<br>  例：/ab{2,5}c/:表示第一个字符是a，接下来是2~5个字符b，最后是字符c</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//g 表示全局匹配</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> regex=<span class=\"regexp\">/ab&#123;2,5&#125;c/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str=<span class=\"string\">&quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(regex))</span><br></pre></td></tr></table></figure>\n<p>  // =&gt; [ ‘abbc’, ‘abbbc’, ‘abbbbc’, ‘abbbbbc’ ]</p>\n</li>\n<li><p>纵向模糊匹配</p>\n<p>  一个匹配的字符串，具体到某一字符时，它可以不是某个确定的字符，可以有多种可能。<br>  使用字符组[abc]:表示该字符可以是a、b、c中的任何一个<br>  例：/a[123]b/: 可以匹配: ‘a1b’,’a2b’,’a3b’</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> regex=<span class=\"regexp\">/a[123]c/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str=<span class=\"string\">&quot;a1c a2c a3c&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(regex))</span><br></pre></td></tr></table></figure>\n<p>  // =&gt; [ ‘a1c’, ‘a2c’, ‘a3c’ ]</p>\n</li>\n</ul>\n<h2 id=\"字符组\"><a href=\"#字符组\" class=\"headerlink\" title=\"字符组\"></a>字符组</h2><p>[abc]</p>\n<h3 id=\"范围表示法\"><a href=\"#范围表示法\" class=\"headerlink\" title=\"范围表示法\"></a>范围表示法</h3><pre><code>如果字符组里的字符特别多，可以使用范围表达式\n</code></pre>\n"},{"title":"读毛选1","date":"2020-12-30T07:58:02.000Z","_content":"\n## 民主自由\n\n实际上，世界上只有具体的自由，具体的民主。没有抽象的民主，抽象的自由。在阶级斗争的社会里，有了剥削阶级剥削劳动人民的自由，就没有劳动人民不受剥削的自由，有了资产阶级的民主，就没有无产阶级和劳动人民的民主。\n\n## ","source":"_posts/毛选.md","raw":"\n---\ntitle: 读毛选1\ndate: 2020-12-30 15:58:02\ncategories: 哲学\ntags: \n- 哲学\n- 毛选\n---\n\n## 民主自由\n\n实际上，世界上只有具体的自由，具体的民主。没有抽象的民主，抽象的自由。在阶级斗争的社会里，有了剥削阶级剥削劳动人民的自由，就没有劳动人民不受剥削的自由，有了资产阶级的民主，就没有无产阶级和劳动人民的民主。\n\n## ","slug":"毛选","published":1,"updated":"2021-11-03T01:21:37.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvj9gblx000vzsw7cjq40320","content":"<h2 id=\"民主自由\"><a href=\"#民主自由\" class=\"headerlink\" title=\"民主自由\"></a>民主自由</h2><p>实际上，世界上只有具体的自由，具体的民主。没有抽象的民主，抽象的自由。在阶级斗争的社会里，有了剥削阶级剥削劳动人民的自由，就没有劳动人民不受剥削的自由，有了资产阶级的民主，就没有无产阶级和劳动人民的民主。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"民主自由\"><a href=\"#民主自由\" class=\"headerlink\" title=\"民主自由\"></a>民主自由</h2><p>实际上，世界上只有具体的自由，具体的民主。没有抽象的民主，抽象的自由。在阶级斗争的社会里，有了剥削阶级剥削劳动人民的自由，就没有劳动人民不受剥削的自由，有了资产阶级的民主，就没有无产阶级和劳动人民的民主。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckvj9gbl40000zsw7gw1a4ruv","category_id":"ckvj9gble0002zsw73t6pczd3","_id":"ckvj9gbln000bzsw7f8bt32fr"},{"post_id":"ckvj9gbli0006zsw70yya7fib","category_id":"ckvj9gble0002zsw73t6pczd3","_id":"ckvj9gblp000gzsw71ioq6r20"},{"post_id":"ckvj9gblb0001zsw7fg2dacyr","category_id":"ckvj9gblj0007zsw7hidu4zrb","_id":"ckvj9gblr000jzsw7496a0xnc"},{"post_id":"ckvj9gblg0004zsw7ejdkb8r1","category_id":"ckvj9gbln000czsw7fva99ays","_id":"ckvj9gblv000qzsw740vxhh2x"},{"post_id":"ckvj9gblh0005zsw7bqpt4ob1","category_id":"ckvj9gblr000kzsw7hrrxet9d","_id":"ckvj9gbly000wzsw77nvs8wy5"},{"post_id":"ckvj9gblk0009zsw7fty4didj","category_id":"ckvj9gblv000rzsw79x5u7kve","_id":"ckvj9gbm00011zsw7apx20r5r"},{"post_id":"ckvj9gblm000azsw749cwafj4","category_id":"ckvj9gbly000xzsw7a5qtdljx","_id":"ckvj9gbm10015zsw78dai5mkb"},{"post_id":"ckvj9gblo000fzsw7hmmo4o86","category_id":"ckvj9gbm00012zsw72piuexdk","_id":"ckvj9gbm40019zsw7aj5c14dk"},{"post_id":"ckvj9gblq000izsw7axth35un","category_id":"ckvj9gblr000kzsw7hrrxet9d","_id":"ckvj9gbm8001dzsw7ccq48wsp"},{"post_id":"ckvj9gbls000nzsw72wumg07w","category_id":"ckvj9gbm40018zsw7bwwb4r5o","_id":"ckvj9gbm9001izsw7fpmjhixy"},{"post_id":"ckvj9gblt000pzsw78hro81my","category_id":"ckvj9gbm40018zsw7bwwb4r5o","_id":"ckvj9gbmb001mzsw735ahauqc"},{"post_id":"ckvj9gblw000tzsw75v99d9nv","category_id":"ckvj9gbm40018zsw7bwwb4r5o","_id":"ckvj9gbmb001ozsw7c922hmib"},{"post_id":"ckvj9gblx000vzsw7cjq40320","category_id":"ckvj9gbma001lzsw7arp4bp9p","_id":"ckvj9gbmc001szsw748wkcy6d"}],"PostTag":[{"post_id":"ckvj9gblk0009zsw7fty4didj","tag_id":"ckvj9gblj0008zsw7hz80al7w","_id":"ckvj9gblo000ezsw7elgf7300"},{"post_id":"ckvj9gbl40000zsw7gw1a4ruv","tag_id":"ckvj9gblg0003zsw79nqn79mi","_id":"ckvj9gblp000hzsw7gp9g1l5i"},{"post_id":"ckvj9gbl40000zsw7gw1a4ruv","tag_id":"ckvj9gblj0008zsw7hz80al7w","_id":"ckvj9gbls000mzsw71n991ju4"},{"post_id":"ckvj9gblb0001zsw7fg2dacyr","tag_id":"ckvj9gbln000dzsw78z3bftob","_id":"ckvj9gblt000ozsw78qrvfa35"},{"post_id":"ckvj9gblt000pzsw78hro81my","tag_id":"ckvj9gblg0003zsw79nqn79mi","_id":"ckvj9gblx000uzsw7030f338a"},{"post_id":"ckvj9gblg0004zsw7ejdkb8r1","tag_id":"ckvj9gbls000lzsw7d8j7cplu","_id":"ckvj9gblz000zzsw7156jgvn9"},{"post_id":"ckvj9gblg0004zsw7ejdkb8r1","tag_id":"ckvj9gblv000szsw7dzh97cxu","_id":"ckvj9gblz0010zsw739tl7ink"},{"post_id":"ckvj9gblh0005zsw7bqpt4ob1","tag_id":"ckvj9gbly000yzsw73ywp167o","_id":"ckvj9gbm00014zsw71mfiftl7"},{"post_id":"ckvj9gbli0006zsw70yya7fib","tag_id":"ckvj9gbm00013zsw7f3w6giub","_id":"ckvj9gbm7001bzsw7bczo1qm0"},{"post_id":"ckvj9gbli0006zsw70yya7fib","tag_id":"ckvj9gblj0008zsw7hz80al7w","_id":"ckvj9gbm8001czsw72bkp2bx0"},{"post_id":"ckvj9gblm000azsw749cwafj4","tag_id":"ckvj9gbm4001azsw74hawdwbd","_id":"ckvj9gbm9001gzsw73jp40yh1"},{"post_id":"ckvj9gblo000fzsw7hmmo4o86","tag_id":"ckvj9gbls000lzsw7d8j7cplu","_id":"ckvj9gbma001kzsw73cewbp6m"},{"post_id":"ckvj9gblq000izsw7axth35un","tag_id":"ckvj9gbly000yzsw73ywp167o","_id":"ckvj9gbmc001qzsw7h99j3x7b"},{"post_id":"ckvj9gblq000izsw7axth35un","tag_id":"ckvj9gbmb001nzsw77qsm385g","_id":"ckvj9gbmc001rzsw73yv8a6z9"},{"post_id":"ckvj9gbls000nzsw72wumg07w","tag_id":"ckvj9gbmb001pzsw7abah31t3","_id":"ckvj9gbmd001uzsw7ewrp436a"},{"post_id":"ckvj9gblw000tzsw75v99d9nv","tag_id":"ckvj9gbmc001tzsw7cxk38v1e","_id":"ckvj9gbmd001wzsw7adusdhr7"},{"post_id":"ckvj9gblx000vzsw7cjq40320","tag_id":"ckvj9gbmd001vzsw74jbfeen7","_id":"ckvj9gbme001yzsw75us42h96"},{"post_id":"ckvj9gblx000vzsw7cjq40320","tag_id":"ckvj9gbmd001xzsw778856h6b","_id":"ckvj9gbme001zzsw76dlg3nhz"}],"Tag":[{"name":"c/c++","_id":"ckvj9gblg0003zsw79nqn79mi"},{"name":"linux","_id":"ckvj9gblj0008zsw7hz80al7w"},{"name":"docker","_id":"ckvj9gbln000dzsw78z3bftob"},{"name":"java","_id":"ckvj9gbls000lzsw7d8j7cplu"},{"name":"spring cloud","_id":"ckvj9gblv000szsw7dzh97cxu"},{"name":"android","_id":"ckvj9gbly000yzsw73ywp167o"},{"name":"mysql","_id":"ckvj9gbm00013zsw7f3w6giub"},{"name":"mongo","_id":"ckvj9gbm4001azsw74hawdwbd"},{"name":"kotlin","_id":"ckvj9gbmb001nzsw77qsm385g"},{"name":"堆栈","_id":"ckvj9gbmb001pzsw7abah31t3"},{"name":"正则","_id":"ckvj9gbmc001tzsw7cxk38v1e"},{"name":"哲学","_id":"ckvj9gbmd001vzsw74jbfeen7"},{"name":"毛选","_id":"ckvj9gbmd001xzsw778856h6b"}]}}